<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Go by Example, MarkHoo&#39;s Blog">
    <meta name="description" content="Hello World我们第一个程序就是打印经典的“hello world”，下面是完整的代码
package main
import &#34;fmt&#34;
func main(){
  fmt.Println(&#34;hello world&#34;)
}

要">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Go by Example | MarkHoo&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
</head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">MarkHoo's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">MarkHoo's Blog</div>
        <div class="logo-desc">
            
            MarkHoo&#39;s Blog | 沉默是金
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Go by Example
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Go/" target="_blank">
                                <span class="chip bg-color">Go</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Go/" class="post-category" target="_blank">
                                Go
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-06-08
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Hello-World"><a href="/2019/06/08/gobyexample/#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们第一个程序就是打印经典的“hello world”，下面是完整的代码</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  fmt.Println(<span class="string">"hello world"</span>)
}
</code></pre>
<p>要运行这个程序，将代码保存为 hello-world.go，然后使用<code>go run</code></p>
<p>有时候我们想让程序编译成二进制文件，可以使用<code>go build</code>，然后就可以直接运行了。</p>
<h2 id="Values"><a href="/2019/06/08/gobyexample/#Values" class="headerlink" title="Values"></a>Values</h2><p>Go 有多种值的类型，包括 string，integer，float，boolean 等。如下是几个基本例子。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//string 可以使用 + 连接在一起</span>
  fmt.Println(<span class="string">"go"</span>+<span class="string">"lang"</span>)
  fmt.Println(<span class="string">"1+1="</span>,<span class="number">1</span>+<span class="number">1</span>)
  fmt.Pritnln(<span class="string">"7.0/3.0="</span>,<span class="number">7.0</span>/<span class="number">3.0</span>)
  fmt.Println(<span class="literal">true</span>&amp;&amp;<span class="literal">false</span>)
  fmt.Println(<span class="literal">true</span>||<span class="literal">false</span>)
  fmt.Pritnln(!<span class="literal">true</span>)
}
</code></pre>
<h2 id="Variables"><a href="/2019/06/08/gobyexample/#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>在 Go 中，变量被编译器显式的声明和使用，例如检查函数调用类型的正确性。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 声明一个或多个变量</span>
  <span class="keyword">var</span> a <span class="keyword">string</span>=<span class="string">"initial"</span>
  fmt.Println(a)
  <span class="keyword">var</span> b,c <span class="keyword">int</span> = <span class="number">1</span>,<span class="number">2</span>
  fmt.Println(b,c)
  <span class="comment">//Go 将推断变量的初始化类型</span>
  <span class="keyword">var</span> d = <span class="literal">true</span>
  fmt.Println(d)
  <span class="comment">// 声明没有初始值的变量将被初始化为零值，如 int 的零值是 0</span>
  <span class="keyword">var</span> e <span class="keyword">int</span>
  fmt.Println(e)
  <span class="comment">//var f string = "short" 的简化写法</span>
  f:=<span class="string">"short"</span>
  fmt.Println(f)
}
</code></pre>
<h2 id="Constants"><a href="/2019/06/08/gobyexample/#Constants" class="headerlink" title="Constants"></a>Constants</h2><p>Go 支持的常量有字符、字符串、布尔值以及数值</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"math"</span>
<span class="keyword">const</span> s <span class="keyword">string</span> = <span class="string">"constant"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  fmt.Println(s)
  <span class="comment">//const 声明可以出现在任何 var 声明出现的地方</span>
  <span class="keyword">const</span> n = <span class="number">50000000</span>
  <span class="comment">// 常量表达式可以任意精度进行运算</span>
  <span class="keyword">const</span> d = <span class="number">3e20</span> / n
  fmt.Println(d)
  <span class="comment">// 数值常量没有类型，除非进行了显式转换等类型赋予</span>
  fmt.Println(<span class="keyword">int64</span>(d))
  <span class="comment">// 数值在使用环境上下文中会得到类型，如变量赋值或者方法调用，如 math.Sin 需要的是一个 float64</span>
  fmt.Println(math.Sin(n))
}
</code></pre>
<h2 id="For"><a href="/2019/06/08/gobyexample/#For" class="headerlink" title="For"></a>For</h2><p>for 是 Go 中唯一的循环结构，下面是三种基本的 for 循环类型。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  i := <span class="number">1</span>
  <span class="comment">// 最基本的类型，只有一个条件</span>
  <span class="keyword">for</span> i&lt;=<span class="number">3</span>{
    fmt.Println(i)
    i = i+<span class="number">1</span>
  }
  <span class="comment">// 经典的 初始化 / 条件 / 循环后 for 循环</span>
  <span class="keyword">for</span> j:=<span class="number">7</span>;j&lt;=<span class="number">9</span>;j++{
    fmt.Println(j)
  }
  <span class="comment">// 没有条件的 for 语句将无限循环，除非在内部的方法中使用了 break 或者 return</span>
  <span class="keyword">for</span>{
    fmt.Println(<span class="string">"loop"</span>)
    <span class="keyword">break</span>
  }
  <span class="comment">// 也可以使用 continue 来直接到下一个循环</span>
  <span class="keyword">for</span> n:=<span class="number">0</span>;n&lt;=<span class="number">5</span>;n++ {
    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span>{
      <span class="keyword">continue</span>
    }
    fmt.Println(n)
  }
}
</code></pre>
<h2 id="If-Else"><a href="/2019/06/08/gobyexample/#If-Else" class="headerlink" title="If/Else"></a>If/Else</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span>==<span class="number">0</span>{
    fmt.Println(<span class="string">"7 is even"</span>)
  }<span class="keyword">else</span>{
    fmt.Println(<span class="string">"7 is odd"</span>)
  }
  <span class="comment">// 可以单独使用 if</span>
  <span class="keyword">if</span> <span class="number">8</span>%<span class="number">4</span>==<span class="number">0</span>{
    fmt.Println(<span class="string">"8 is divisible by 4"</span>)
  }
  <span class="comment">// 条件之前可以有语句，声明在该语句中的任何变量可以用于所有分支</span>
  <span class="keyword">if</span> num:=<span class="number">9</span>;num&lt;<span class="number">0</span>{
    fmt.Println(num,<span class="string">"is negative"</span>)
  }<span class="keyword">else</span> <span class="keyword">if</span> num&lt;<span class="number">10</span>{
    fmt.Println(num,<span class="string">"has 1 digit"</span>)
  }<span class="keyword">else</span>{
    fmt.Println(num,<span class="string">"has multiple digits"</span>)
  }
}
</code></pre>
<p>注意，Go 中条件周围不需要圆括号，但是花括号是必要的。</p>
<p>Go 中没有三目 if 语句，所以对于最基本的条件也需要写完整的 if 语句。</p>
<h2 id="Switch"><a href="/2019/06/08/gobyexample/#Switch" class="headerlink" title="Switch"></a>Switch</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  i:=<span class="number">2</span>
  fmt.Print(<span class="string">"write"</span>,i,<span class="string">"as"</span>)
  <span class="keyword">switch</span> i{
  <span class="keyword">case</span> <span class="number">1</span>: fmt.Println(<span class="string">"one"</span>)
  <span class="keyword">case</span> <span class="number">2</span>: fmt.Println(<span class="string">"two"</span>)
  <span class="keyword">case</span> <span class="number">3</span>: fmt.Println(<span class="string">"three"</span>)
  }
  <span class="comment">// 可以在同一个 case 语句中使用逗号来分隔多个表达式</span>
  <span class="keyword">switch</span> time.Now().weekday(){
  <span class="keyword">case</span> time.Saturday,time.Sunday:
    fmt.Println(<span class="string">"it's the weekend"</span>)
  <span class="comment">// 这里也使用了 default case</span>
  <span class="keyword">default</span>:
    fmt.Println(<span class="string">"it's a weekday"</span>)
  }
  t:=time.Now()
  <span class="comment">// 没有表达式的 switch 是另一种实现 if/else 逻辑的路子，同时这也展示了 case 表达式可以是非常量值。</span>
  <span class="keyword">switch</span>{
  <span class="keyword">case</span> t.Hour()&lt;<span class="number">12</span>:
    fmt.Println(<span class="string">"it's before noon"</span>)
  <span class="keyword">default</span>:
    fmt.Println(<span class="string">"it's after noon"</span>)
  }
  <span class="comment">// 类型 switch 比较了类型而非值</span>
  whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>{})</span></span>{
    <span class="keyword">switch</span> t:=i.(<span class="keyword">type</span>){
    <span class="keyword">case</span> <span class="keyword">bool</span>:
      fmt.Println(<span class="string">"I'm a bool"</span>)
    <span class="keyword">case</span> <span class="keyword">int</span>:
      fmt.Println(<span class="string">"I'm an int"</span>)
    <span class="keyword">default</span>:
      fmt.Println(<span class="string">"Don't know type %T\n"</span>,t)
    }
  }
  whatAmI(<span class="literal">true</span>)
  whatAmI(<span class="number">1</span>)
  whatAmI(<span class="string">"hey"</span>)
}
</code></pre>
<h2 id="Arrays"><a href="/2019/06/08/gobyexample/#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>在 Go 中，数组是特定长度元素的编号序列。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里创建了一个 5 个 int 元素的数组。默认是零值，对于 int 而言就是 0</span>
  <span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span>
  fmt.Println(<span class="string">"emp:"</span>,a)
  <span class="comment">// 可以通过 array[index]=value 语法设值，或者通过 array[index] 取值</span>
  a[<span class="number">4</span>]=<span class="number">100</span>
  fmt.Println(<span class="string">"set:"</span>,a)
  fmt.Println(<span class="string">"get:"</span>,a[<span class="number">4</span>])
  <span class="comment">// 内置的 len 函数返回数组的长度</span>
  fmt.Println(<span class="string">"len:"</span>,<span class="built_in">len</span>(a))
  <span class="comment">// 声明并初始化数组</span>
  b:=[<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}
  fmt.Prinln(<span class="string">"dc1:"</span>,b)
  <span class="comment">// 数组是一维的，但你可以组合类型来构建多维数组结构</span>
  <span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++{
    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++{
      twoD[i][j]=i+j
    }
  }
  fmt.Println(<span class="string">"2d:"</span>,twoD)
}
</code></pre>
<p>当使用 fmt.Println 方法打印时，数组将以 [v1 v2 v3 …] 的形式展现</p>
<h2 id="Slices"><a href="/2019/06/08/gobyexample/#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>slice 是一个重要的数据类型，对于序列提供了比数组更强大的接口</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 与数组不同，切片仅由其包含的元素（不是元素的数量）键入。 </span>
  <span class="comment">// 要创建一个非零长度的空切片，请使用内置的 make。 这里我们制作长度为 3 的字符串（最初为零值）。</span>
  s:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">3</span>)
  fmt.Println(<span class="string">"emp:"</span>,s)
  <span class="comment">// 可以像数组一样 set 和 get</span>
  s[<span class="number">0</span>]=<span class="string">"a"</span>
  s[<span class="number">1</span>]=<span class="string">"b"</span>
  s[<span class="number">2</span>]=<span class="string">"c"</span>
  fmt.Println(<span class="string">"set:"</span>,s)
  fmt.Println(<span class="string">"get:"</span>,s[<span class="number">2</span>])
  <span class="comment">//len 能够返回 slice 的长度</span>
  fmt.Println(<span class="string">"len:"</span>,<span class="built_in">len</span>(s))
  <span class="comment">// 作为这些基本操作的补充，slice 支持一些令其比数组更丰富的东西。</span>
  <span class="comment">// 其中一个是 append 函数，其返回一个包含一个或多个新值的 slice</span>
  <span class="comment">// 注意需要接受 append 的返回值来获取新的 slice 值</span>
  s=<span class="built_in">append</span>(s,<span class="string">"d"</span>)
  s=<span class="built_in">append</span>(s,<span class="string">"e"</span>,<span class="string">"f"</span>)
  fmt.Println(<span class="string">"apd:"</span>,s)
  <span class="comment">//slice 可以复制</span>
  c:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="built_in">len</span>(s))
  <span class="built_in">copy</span>(c,s)
  fmt.Println(<span class="string">"cpy:"</span>,c)
  <span class="comment">//slice 支持切片操作，语法为 slice[low:high]。如下将得到元素 s[2],s[3] 和 s[4]</span>
  l:=s[<span class="number">2</span>:<span class="number">5</span>]
  fmt.Println(<span class="string">"sl1:"</span>,l)
  <span class="comment">// 如下切片截止到（不包含）s[5]</span>
  l=s[:<span class="number">5</span>]
  fmt.Pritnln(<span class="string">"sl2:"</span>,l)
  <span class="comment">// 如下切片从 s[2] 开始（包含）</span>
  l=s[<span class="number">2</span>:]
  fmt.Println(<span class="string">"sl3:"</span>,l)
  <span class="comment">// 声明并初始化 slice</span>
  t:=[]<span class="keyword">string</span>{<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>}
  fmt.Println(<span class="string">"dcl:"</span>,t)
  <span class="comment">//slice 也可以组织成一个多为数据结构，内部的 slice 长度可以变化，这与多维数组不同</span>
  twoD:=<span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">3</span>)
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++{
    innerLen:=i+<span class="number">1</span>
    twoD[i]=<span class="built_in">make</span>([]<span class="keyword">int</span>,innerLen)
    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;innerLen;j++{
      twoD[i][j]=i+j
    }
  }
  fmt.Println(<span class="string">"2d:"</span>,twoD)
}
</code></pre>
<p>虽然 slice 与 array 是不同的类型，但是使用 fmt.Println 的展示结果很相似</p>
<h2 id="Maps"><a href="/2019/06/08/gobyexample/#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>Map 是 Go 内置的关联数据类型（其他语言可能成为哈希或者字典）</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 要创建一个空的 map，使用内置 make 函数：make(map[key-type]val-type)</span>
  m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)
  <span class="comment">// 通过经典的 name[key]=val 语法来设置 key/value 对</span>
  m[<span class="string">"k1"</span>]=<span class="number">7</span>
  m[<span class="string">"k2"</span>]=<span class="number">13</span>
  fmt.Println(<span class="string">"map:"</span>,m)
  <span class="comment">// 通过 name[key] 来获取一个 value</span>
  v1:=m[<span class="string">"k1"</span>]
  fmt.Println(<span class="string">"v1:"</span>,v1)
  <span class="comment">//len 函数返回 map 中键值对的个数</span>
  fmt.Println(<span class="string">"len:"</span>,<span class="built_in">len</span>(m))
  <span class="comment">// 内置的 delete 函数将移除 map 中的键值对</span>
  <span class="built_in">delete</span>(m,<span class="string">"k2"</span>)
  fmt.Println(<span class="string">"map:"</span>,m)
  <span class="comment">// 第一个值是该 key 的 value，但此处不需要，故使用空白占位符“_”忽略</span>
  <span class="comment">// 第二个可选的返回值表明该键是否在 map 中，这样可以消除不存在的键，和键值为 0 或者 "" 的歧义</span>
  _,prs:=m[<span class="string">"k2"</span>]
  fmt.Println(<span class="string">"prs:"</span>,prs)
  <span class="comment">// 声明并初始化 map</span>
  n:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>{<span class="string">"foo"</span>:<span class="number">1</span>,<span class="string">"bar"</span>:<span class="number">2</span>}
  fmt.Println(<span class="string">"map:"</span>,n)
}
</code></pre>
<p>map 将以 [k:v k:v] 的形式打印</p>
<h2 id="Range"><a href="/2019/06/08/gobyexample/#Range" class="headerlink" title="Range"></a>Range</h2><p>range 可以遍历各种数据结构中的元素。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里使用 range 来计算元素的和，数组也是类似的用法</span>
  nums:=[]<span class="keyword">int</span>{<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}
  sum:=<span class="number">0</span>
  <span class="keyword">for</span> _,num:=<span class="keyword">range</span> nums{
    sum+=num
  }
  fmt.Println(<span class="string">"sum:"</span>,sum)
  <span class="comment">// 在 slice 和 array 上的 range 均为每个条目提供了索引和值</span>
  <span class="keyword">for</span> i,num:=<span class="keyword">range</span> nums{
    <span class="keyword">if</span> num==<span class="number">3</span>{
      fmt.Pritnln(<span class="string">"index"</span>,i)
    }
  }
  <span class="comment">//map 上的 range 通过 key/value 对进行遍历</span>
  kvs:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{<span class="string">"a"</span>:<span class="string">"apple"</span>,<span class="string">"b"</span>:<span class="string">"banana"</span>}
  <span class="keyword">for</span> k,v:=<span class="keyword">range</span> kvs{
    fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>,k,v)
  }
  <span class="comment">//range 可以仅通过 key 进行遍历</span>
  <span class="keyword">for</span> k:= <span class="keyword">range</span> kvs{
    fmt.Println(<span class="string">"key:"</span>,k)
  }
  <span class="comment">//range 作用在 string 上将得到 unicode code points，第一个值是字符的起始字节索引，第二个值是字符本身</span>
  <span class="keyword">for</span> i,c:<span class="keyword">range</span> <span class="string">"go"</span> {
    cmt.Println(i,c)
  }
}
</code></pre>
<h2 id="Functions"><a href="/2019/06/08/gobyexample/#Functions" class="headerlink" title="Functions"></a>Functions</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 这个函数接收两个 int 并以 int 类型返回他们的和</span>
<span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>{
  <span class="comment">//Go 需要显式的 return 语句，它不会自动返回最后一个表达式的值</span>
  <span class="keyword">return</span> a+b
}
<span class="comment">// 如果有多个连续的相同类型的参数，可以忽略前面的类型声明</span>
<span class="function"><span class="keyword">func</span> <span class="title">plusPlus</span><span class="params">(a,b,c <span class="keyword">int</span>)</span> <span class="title">int</span></span>{
  <span class="keyword">return</span> a+b+c
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 如你所想的那样调用函数</span>
  res := plus(<span class="number">1</span>,<span class="number">2</span>)
  fmt.Println(<span class="string">"1+2="</span>,res)
  res = plusPlus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  fmt.Println(<span class="string">"1+2+3="</span>,res)
}
</code></pre>
<h2 id="Multiple-Return-Values"><a href="/2019/06/08/gobyexample/#Multiple-Return-Values" class="headerlink" title="Multiple Return Values"></a>Multiple Return Values</h2><p>Go 内置支持了返回多个值。这一特点经常用于 Go 的习惯用法，例如同时返回结果和错误值</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 方法签名中的 (int,int) 表明它将返回两个 int 值</span>
<span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>{
  <span class="keyword">return</span> <span class="number">3</span>,<span class="number">7</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里我们通过多重赋值来使用两个不同的返回值</span>
  a,b := vals()
  fmt.Println(a)
  fmt.Println(b)
  <span class="comment">// 如果只需要返回结果的子集，使用空白占位符 _</span>
  _,c := vals()
  fmt.Println(c)
}
</code></pre>
<h2 id="Variadic-Functions"><a href="/2019/06/08/gobyexample/#Variadic-Functions" class="headerlink" title="Variadic Functions"></a>Variadic Functions</h2><p>变参函数，可以使用任意数量的参数来进行调用。例如 fmt.Println 是一个常见的变参函数。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 这是一个接收任意数量的 int 值的函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span>{
  fmt.Print(nums,<span class="string">" "</span>)
  total := <span class="number">0</span>
  <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums{
    total += num
  }
  fmt.Println(total)
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  sum(<span class="number">1</span>,<span class="number">2</span>)
  sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  <span class="comment">// 如果你已经在一个 slice 中定义了多个参数，可以使用 func(slice...) 来直接应用到变参函数中</span>
  nums :=[]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}
  sum(nums...)
}
</code></pre>
<h2 id="Closures"><a href="/2019/06/08/gobyexample/#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>Go 支持匿名函数，它可以形成闭包。当你想要定义一个不记名的内部函数时，匿名函数就很有用了。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">//intSeq 函数返回另一个函数，它定义在了 intSeq 函数内部，并且是匿名的。</span>
<span class="comment">// 返回的函数关闭变量 i 以形成闭包</span>
<span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span> <span class="title">int</span></span>{
  i := <span class="number">0</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>{
    i+=<span class="number">1</span>
    <span class="keyword">return</span> i
  }
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 调用 intSeq，并将结果 (一个函数) 赋予 nextInt</span>
  <span class="comment">// 这个函数持有一个自己的 i 值，每次调用 nextInt 时都会更新</span>
  nextInt:=intSeq()
  <span class="comment">// 多次调用 nextInt 函数可以看到闭包的效果</span>
  <span class="comment">//zephyr: 如非闭包写法，每次函数都会进行初始化变量 i，反复调用 intSeq 不会有这个效果</span>
  fmt.Println(nextInt())
  fmt.Println(nextInt())
  fmt.Pritnln(nextInt())
  <span class="comment">// 要确认该状态对该特定函数是唯一的，请创建并测试一个新函数。</span>
  newInts:=intSeq()
  fmt.Println(newInts())
}
</code></pre>
<h2 id="Recursion"><a href="/2019/06/08/gobyexample/#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p>Go 支持递归函数。下面是一个经典的斐波那契数列示例</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> {
  <span class="keyword">if</span> n==<span class="number">0</span> {
    <span class="keyword">return</span> <span class="number">1</span>
  }
  <span class="comment">//fact 函数调用自身，直到 n 为 0</span>
  <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  fmt.Println(fact(<span class="number">7</span>))
}
</code></pre>
<h2 id="Pointers"><a href="/2019/06/08/gobyexample/#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>Go 可以使用指针，让你在程序中传递值或记录的引用。</p>
<p>下面通过两种方式的对比来展示指针的使用：<code>zeroval</code>和<code>zeroptr</code></p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">//zeroval 将取得 ival 的值的拷贝，与调用方不同</span>
<span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="keyword">int</span>)</span></span>{
  ival = <span class="number">0</span>
}
<span class="comment">//zeroptr 有一个 *int 类型的参数，代表它接收的是一个指针</span>
<span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="keyword">int</span>)</span></span>{
  <span class="comment">//*iptr 解引用，从内存指定地址中获取存放的值</span>
  <span class="comment">// 对解引用指针的赋值将改变指定地址上的值</span>
  *iptr = <span class="number">0</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  i:=<span class="number">1</span>
  fmt.Println(<span class="string">"initial:"</span>,i)
  zeroval(i)
  fmt.Println(<span class="string">"zeroval:"</span>,i)
  <span class="comment">//&amp;i 语法将获得变量 i 的内存地址，也就是指向变量 i 的指针</span>
  zeroptr(&amp;i)
  fmt.Println(<span class="string">"zeroptr:"</span>,i)
  <span class="comment">// 指针也可以被打印</span>
  fmt.Println(<span class="string">"pointer:"</span>,&amp;i)
}
</code></pre>
<p>zeroval 没有改变 main 函数中 i 的值，而 zeroptr 会，因为它拥有指向变量 i 的内存地址。</p>
<h2 id="Structs"><a href="/2019/06/08/gobyexample/#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>Go 的 Struct 结构是字段类型的集合。对于从记录中将数据组织到一起很有帮助。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">type</span> person <span class="keyword">struct</span>{
  name <span class="keyword">string</span>
  age <span class="keyword">int</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这个语法创建了一个新的 struct</span>
  fmt.Println(person{<span class="string">"Bob"</span>,<span class="number">20</span>})
  <span class="comment">// 在初始化 struct 时，可以指定字段名</span>
  fmt.Println(person{name:<span class="string">"Alice"</span>,age:<span class="number">30</span>})
  <span class="comment">// 被忽略的字段将会被初始化为零</span>
  fmt.Println(person{name:<span class="string">"Fred"</span>})
  <span class="comment">// 一个 &amp; 将产生 struct 的指针</span>
  fmt.Println(&amp;person{name:<span class="string">"Ann"</span>,age:<span class="number">40</span>})
  s:=person{name:<span class="string">"Sean"</span>,age:<span class="number">50</span>}
  <span class="comment">// 通过点号访问结构体中的字段</span>
  fmt.Println(s.name)
  sp:=&amp;s
  fmt.Println(sp.age)
  <span class="comment">// 对于结构体的指针也可以使用点号操作符，指针将会自动解引用</span>
  sp.age=<span class="number">51</span>
  <span class="comment">// 结构体是可变的</span>
  fmt.Println(sp.age)
}
</code></pre>
<h2 id="Methods"><a href="/2019/06/08/gobyexample/#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go 支持在结构体上定义方法。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">type</span> rect <span class="keyword">struct</span>{
  width,height <span class="keyword">int</span>
}
<span class="comment">//area 方法有一个 rect 指针类型的接收器</span>
<span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span>{
  <span class="keyword">return</span> r.width * r.height
}
<span class="comment">// 即可以定义指针类型的接收器，也可以定义值类型的接收器</span>
<span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">int</span></span>{
  <span class="keyword">return</span> <span class="number">2</span>*r.width+<span class="number">2</span>*r.height
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  r:=rect{width:<span class="number">10</span>,height:<span class="number">5</span>}
  <span class="comment">// 调用定义的方法</span>
  fmt.Println(<span class="string">"area:"</span>,r.area())
  fmt.Println(<span class="string">"perim:"</span>,r.perim())
  <span class="comment">//Go 为方法调用自动处理了值和引用的转换。使用指针接收器可以避免获得方法调用的拷贝 (?) 或允许方法修改接收到的 struct 值</span>
  rp:=&amp;r
  fmt.Println(<span class="string">"area:"</span>,rp.area())
  fmt.Println(<span class="string">"perim:"</span>,rp.perim())
}
</code></pre>
<h2 id="Interfaces"><a href="/2019/06/08/gobyexample/#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口是方法签名的命名集合。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"math"</span>
<span class="comment">// 这是一个 geometry 的基本接口，本例中将在 rect 类型和 circle 类型中实现这个接口</span>
<span class="keyword">type</span> geometry <span class="keyword">interface</span>{
  area() <span class="keyword">float64</span>
  perim() <span class="keyword">float64</span>
}
<span class="keyword">type</span> rect <span class="keyword">struct</span>{
  width,height <span class="keyword">float64</span>
}
<span class="keyword">type</span> circle <span class="keyword">struct</span>{
  radius <span class="keyword">float64</span>
}
<span class="comment">// 在 Go 中，实现一个接口只需要实现其中定义的所有方法即可</span>
<span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span>{
  <span class="keyword">return</span> r.width * r.height
}
<span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span>{
  <span class="keyword">return</span> <span class="number">2</span>*r.width+<span class="number">2</span>*r.height
}
<span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span>{
  <span class="keyword">return</span> math.Pi * c.radius * c.radius
}
<span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span>{
  <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius
}
<span class="comment">// 如果变量是接口类型，那么它可以调用接口内定义的方法</span>
<span class="comment">// 这是一个通用的 measure 方法，利用它能够工作在任何 geometry 上</span>
<span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span>{
  fmt.Println(g)
  fmt.Println(g.area())
  fmt.Println(g.perim())
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  r:=rect{width:<span class="number">3</span>,height:<span class="number">4</span>}
  c:=circle{radius:<span class="number">5</span>}
  <span class="comment">//rect 和 circle 均实现了 geometry 接口，所以可以作为 measure 的参数</span>
  measure(r)
  measure(c)
}
</code></pre>
<h2 id="Errors"><a href="/2019/06/08/gobyexample/#Errors" class="headerlink" title="Errors"></a>Errors</h2><p>在 Go 中，传递错误的惯用法是通过明确的，分离的返回值。这和 Java 活 Ruby 中的 exception 以及 C 中重载使用单个的结果 / 错误值不同。Go 的方法使得很容易看出哪些函数返回错误，并使用与任何其他非错误任务相同的语言结构来处理它们。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"errors"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 按照惯例，错误是最后一个返回值，类型为 error，一个内置的接口。</span>
<span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>,error)</span></span>{
  <span class="keyword">if</span> arg==<span class="number">42</span>{
    <span class="comment">//errors.New 使用给定的错误信息构建了一个基本的 error 值</span>
    <span class="keyword">return</span> <span class="number">-1</span>,errors.New(<span class="string">"can't work with 42"</span>)
  }
  <span class="comment">// 在 error 位置上放 nil 值代表没有错误</span>
  <span class="keyword">return</span> arg+<span class="number">3</span>,<span class="literal">nil</span>
}
<span class="comment">// 通过实现 Error() 方法，可以自定义错误类型。这里有一个上例的变种</span>
<span class="comment">// 使用一个自定义类型来显式地展示一个参数错误</span>
<span class="keyword">type</span> argError <span class="keyword">struct</span>{
  arg <span class="keyword">int</span>
  prob <span class="keyword">string</span>
}
<span class="keyword">type</span> argError <span class="keyword">struct</span>{
  arg <span class="keyword">int</span>
  prob <span class="keyword">string</span>
}
<span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>{
  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>,e.arg,e.prob)
}
<span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>,error)</span></span>{
  <span class="keyword">if</span> arg==<span class="number">42</span>{
    <span class="comment">// 这里我们使用 &amp;argError 语法来创建一个新的结构体，提供了 arg 和 prob 两个域的值</span>
    <span class="keyword">return</span> <span class="number">-1</span>,&amp;argError{arg,<span class="string">"can't work with it"</span>}
  }
  <span class="keyword">return</span> arg+<span class="number">3</span>,<span class="literal">nil</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 下面的两个循环测试了每个返回 error 的函数</span>
  <span class="comment">// 注意在 if 中的错误检查是 Go 代码中的习惯用法</span>
  <span class="keyword">for</span> _,i:=<span class="keyword">range</span> []<span class="keyword">int</span>{<span class="number">7</span>,<span class="number">42</span>}{
    <span class="keyword">if</span> r,e:=f1(i);e!=<span class="literal">nil</span>{
      fmt.Println(<span class="string">"f1 failed:"</span>,e)
    }<span class="keyword">else</span>{
      fmt.Println(<span class="string">"f1 worked:"</span>,r)
    }
  }
  <span class="keyword">for</span> _,i := <span class="keyword">range</span> []<span class="keyword">int</span>{<span class="number">7</span>,<span class="number">42</span>}{
    <span class="keyword">if</span> r,e :=f2(i);e!=<span class="literal">nil</span>{
      fmt.Println(<span class="string">"f1 failed:"</span>,e)
    }<span class="keyword">else</span>{
      fmt.Println(<span class="string">"f1 worked:"</span>,r)
    }
  }
  <span class="comment">// 如果要以编程方式使用自定义错误中的数据，</span>
  <span class="comment">// 则需要通过类型断言将错误作为自定义错误类型的实例获取。</span>
  _,e:=f2(<span class="number">42</span>)
  <span class="keyword">if</span> ae,ok := e.(*argError);ok{
    fmt.Println(ae.arg)
    fmt.Println(ae.prob)
  }
}
</code></pre>
<h2 id="Goroutines"><a href="/2019/06/08/gobyexample/#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>goroutine 是一个轻量级的执行线程。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span>{
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++{
    fmt.Println(from,<span class="string">";"</span>,i)
  }
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 假设我们有个 f(s) 的函数调用。这里我们通过一般方法调用，令其同步执行</span>
  f(<span class="string">"direct"</span>)
  <span class="comment">// 要想让这个函数在 goroutine 中触发，使用 go f(s)。这个新的 goroutine 将会与调用它的并行执行</span>
  <span class="keyword">go</span> f(<span class="string">"goroutine"</span>)
  <span class="comment">// 我们也可以启动一个调用匿名函数的 goroutine</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span>{
  fmt.Println(msg)
  }(<span class="string">"going"</span>)
  <span class="comment">// 现在，这两个方法调用在独立的 goroutine 中异步执行了，故方法执行直接落到了这里</span>
  <span class="comment">//Scanln 代码需要在程序退出前按下一个键</span>
  <span class="keyword">var</span> input <span class="keyword">string</span>
  fmt.Scanln(&amp;input)
  fmt.Println(<span class="string">"done"</span>)
}
</code></pre>
<p>当我们运行这个程序的时候，我们将首先看到阻塞调用，然后是两个 goroutine 的交错输出。这个交错反应了 goroutine 在 Go 运行时是并发执行的。</p>
<h2 id="Channels"><a href="/2019/06/08/gobyexample/#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Channel 是连接并发执行的 goroutine 的管道。你可以从一个 goroutine 传递值到 channel 中，再在另一个 goroutine 接收它。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 通过 make(chan val-type) 创建新的 channel</span>
  <span class="comment">//channel 的类型依赖于它们要传递的值</span>
  messages:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)
  <span class="comment">// 向 channel 传递值使用 channel &lt;- 语法。在这里我们从一个新的 goroutine 中发送了一个 "ping" 到 message 通道中</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{messages&lt;-<span class="string">"ping"</span>}()
  <span class="comment">//&lt;-channel 语法从 channel 中获取值。这里我们接收了上面发送的 "ping" 信息并打印</span>
  msg:=&lt;-messages
  fmt.Println(msg)
}
</code></pre>
<p>当我们运行这个程序时，”ping” 信息成功的通过我们的 channel 从一个 goroutine 传递到了另一个。</p>
<p>默认情况下，发送和接收在发送者和接受者都准备好之前阻塞。这个特性允许我们在程序结尾等待 “ping” 信息而无需使用其他的同步手段</p>
<h2 id="Channel-Buffering"><a href="/2019/06/08/gobyexample/#Channel-Buffering" class="headerlink" title="Channel Buffering"></a>Channel Buffering</h2><p>默认下 channel 没有缓冲区，这意味着他们将只有在响应的接收者 (&lt;-chan) 准备好时，才能允许发送 (chan&lt;-)。具有缓冲区的 channel，接受有限个数的值，而无需相应的接收者。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里我们创建了一个能够缓冲 2 个字符串值的 channel</span>
  messages:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">2</span>)
  <span class="comment">// 由于 channel 带有缓冲区，我们可以发送值，无需响应的并发接收</span>
  messages&lt;-<span class="string">"buffered"</span>
  messages&lt;-<span class="string">"channel"</span>
  <span class="comment">// 稍后，我们像往常一样，接收了这两个值</span>
  fmt.Println(&lt;-messages)
  fmt.Println(&lt;-messages)
}
</code></pre>
<h2 id="Channel-Synchronization"><a href="/2019/06/08/gobyexample/#Channel-Synchronization" class="headerlink" title="Channel Synchronization"></a>Channel Synchronization</h2><p>我们可以使用 channel 来跨 goroutine 同步执行。这里是一个使用阻塞接收来等待 goroutine 结束的例子。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="comment">// 这个方法将在一个 goroutine 中运行。</span>
<span class="comment">//done channel 用来通知其他的 goroutine 这个方法执行完毕</span>
<span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>{
  fmt.Print(<span class="string">"working..."</span>)
  time.Sleep(time.Second)
  fmt.Println(<span class="string">"done"</span>)
  <span class="comment">// 发送一个值来通知这里已经做完</span>
  done&lt;-<span class="literal">true</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  启动一个worker goroutine，赋予它用以通知的channel
  done:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)
  <span class="keyword">go</span> worker(done)
  <span class="comment">// 在 channel 接收到来自 worker 的通知前，保持阻塞</span>
  &lt;-done
}
</code></pre>
<p>如果你移除了 &lt;-done 行，这个程序可能会在 worker 开始前就结束。</p>
<h2 id="Channel-Directions"><a href="/2019/06/08/gobyexample/#Channel-Directions" class="headerlink" title="Channel Directions"></a>Channel Directions</h2><p>当把 channel 用作函数的参数时，你可以指定一个 channel 是否只发送或者只接收数据。这种特异性增加了程序的类型安全性。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">//ping 函数只接受一个发送数据的 channel，如果试图在其上获取数据，将会引发编译时异常</span>
<span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>,msg <span class="keyword">string</span>)</span></span>{
  pings&lt;-msg
}
<span class="comment">//pong 函数接受一个通道用于接收 (pings)，另一个用于发送 (pongs)</span>
<span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>,pongs <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span>{
  msg:=&lt;-pings
  pongs&lt;-msg
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  pings:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">1</span>)
  pongs:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">1</span>)
  ping(pings,<span class="string">"passed message"</span>)
  pong(pings,pongs)
  fmt.Println(&lt;-pongs)
}
</code></pre>
<h2 id="Select"><a href="/2019/06/08/gobyexample/#Select" class="headerlink" title="Select"></a>Select</h2><p>Go 的 select 让你能够等待多个 channel 操作。通过 select 结合 goroutine 和 channel 是 Go 的重要特色。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 本例中我们将在两个通道中进行选择</span>
  c1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)
  c2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)
  <span class="comment">// 每个通道都会在一定时间后接收到一个值，在并发的 goroutine 中模拟阻塞 RPC 操作执行</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    time.Sleep(time.Second*<span class="number">1</span>)
    c1&lt;-<span class="string">"one"</span>
  }()
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    time.Sleep(time.Second*<span class="number">2</span>)
    c2&lt;-<span class="string">"two"</span>
  }()
  <span class="comment">// 我们将使用 select 来同时等待这两个值，当它们到达时打印。</span>
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++{
    <span class="keyword">select</span>{
    <span class="keyword">case</span> msg1:=&lt;-c1:
      fmt.Println(<span class="string">"received"</span>,msg1)
    <span class="keyword">case</span> msg2:=&lt;-c2:
      fmt.Println(<span class="string">"received"</span>,msg2)
    }
  }
}
</code></pre>
<p>按照预期，我们将接收到 “one”，然后 “two”。</p>
<p>注意，整个执行只需要大约 2 秒的时间，因为 1 秒和 2 秒的沉睡是并发执行的。</p>
<h2 id="Timeouts"><a href="/2019/06/08/gobyexample/#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><p>超时对于连接到外部资源的程序或其他需要绑定执行时间的程序很重要。在 Go 中，可以通过 channel 和 select 轻松而优雅的实现超时。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 在本例中，假设我们执行了一个外部调用，它在两秒后将结果返回到通道 c1 上</span>
  c1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">1</span>)
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    time.Sleep(time.Second*<span class="number">2</span>)
    c1&lt;-<span class="string">"result 1"</span>
  }()
  <span class="comment">// 这里是用 select 实现超时。res:=&lt;-c1 等待一个结果，而 &lt;-Time.After 等待超时 1 秒后发送一个值。</span>
  <span class="comment">// 由于 select 将在有第一个准备就绪的接收时继续，我们会在操作超过允许的 1 秒时进入超时事件。</span>
  <span class="keyword">select</span>{
  <span class="keyword">case</span> res:=&lt;-c1:
    fmt.Println(res)
  <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">1</span>):
    fmt.Println(<span class="string">"timeout 1"</span>)  
  }
  <span class="comment">// 如果我们允许一个更长的超时时间 3 秒，则将能成功得到 c2 的值，并打印</span>
  c2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">1</span>)
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    time.Sleep(time.Second*<span class="number">2</span>)
    c2&lt;-<span class="string">"result 2"</span>
  }()
  <span class="keyword">select</span>{
  <span class="keyword">case</span> res:=&lt;-c2:
    fmt.Println(res)
  <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">3</span>):
    fmt.Printnln(<span class="string">"timeout 2"</span>)
  }
}
</code></pre>
<p>运行这个程序，将显示第一个操作超时了，第二个则成功。</p>
<p>使用 select 超时模式需要在通道上进行结果通讯。一般情况下这是很好的主意，因为其他的重要 Go 特性基于通道和选择。我们将在之后看到有关的两个例子：timer 和 ticker</p>
<h2 id="Non-Blocking-Channel-Operations"><a href="/2019/06/08/gobyexample/#Non-Blocking-Channel-Operations" class="headerlink" title="Non-Blocking Channel Operations"></a>Non-Blocking Channel Operations</h2><p>channel 上简单的发送和接收是阻塞的。然而，我们可以使用 select 和 default 子句来实现非阻塞发送、接收甚至非阻塞的多路选择。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  messages:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)
  signals:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)
  <span class="comment">// 这是一个非阻塞的接收。如果 message 的值可以获取，select 将随值进入 &lt;-message 子句</span>
  <span class="comment">// 否则将立刻进入 default 事件</span>
  <span class="keyword">select</span>{
  <span class="keyword">case</span> msg:=&lt;-messages:
    fmt.Println(<span class="string">"received message"</span>,msg)
  <span class="keyword">default</span>:
    fmt.Pritln(<span class="string">"no message received"</span>)
  }
  msg:=<span class="string">"hi"</span>
  <span class="comment">// 类似的有非阻塞发送</span>
  <span class="keyword">select</span>{
  <span class="keyword">case</span> messages&lt;-msg:
    cmt.Println(<span class="string">"sent message"</span>,msg)
  <span class="keyword">default</span>:
    fmt.Println(<span class="string">"no message sent"</span>)
  }
  <span class="comment">// 我们可以在 default 上使用多个事件来实现多路非阻塞 select。</span>
  <span class="comment">// 这里我们试图在 message 和 signal 上均进行非阻塞接收</span>
  <span class="keyword">select</span>{
  <span class="keyword">case</span> msg:=&lt;-messages:
    fmt.Println(<span class="string">"received message"</span>,msg)
  <span class="keyword">case</span> sig:=&lt;-signals:
    fmt.Println(<span class="string">"received signal"</span>,sig)
  <span class="keyword">default</span>:
    fmt.Println(<span class="string">"no activity"</span>)
  }
}
</code></pre>
<h2 id="Closing-Channels"><a href="/2019/06/08/gobyexample/#Closing-Channels" class="headerlink" title="Closing Channels"></a>Closing Channels</h2><p>关闭通道意味着不会再有值在其上发送。这对于通道的接收方通讯完成很有帮助</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 在这个例子中，我们将使用一个作业通道将工作从主函数 goroutine 传递给工人 goroutine。当没有更多作业给工人时，我们将关闭工作渠道。</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  jobs:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">5</span>)
  done:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)
  <span class="comment">// 下面是工人 goroutine。它通过 j,more:=&lt;-jobs 反复获取作业</span>
  <span class="comment">// 在这个 2 返回值的接收中，如果作业关闭，所有值都已接收，more 会变为 false</span>
  <span class="comment">// 我们用其在完成所有作业时进行已完成通知</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    <span class="keyword">for</span>{
      j,more:=&lt;-jobs
      <span class="keyword">if</span> more{
        fmt.Println(<span class="string">"received job"</span>,j)
      }<span class="keyword">else</span>{
        fmt.Println(<span class="string">"received all jobs"</span>)
        done&lt;-<span class="literal">true</span>
        <span class="keyword">return</span>
      }
    }
  }()
  <span class="comment">// 此处向工人发送了 3 个作业，然后关闭它</span>
  <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++{
    jobs&lt;-j
    fmt.Println(<span class="string">"sent job"</span>,j)
  }
  <span class="built_in">close</span>(jobs)
  fmt.Println(<span class="string">"sent all jobs"</span>)
  <span class="comment">// 使用前面见过的同步机制来等待工人、</span>
  &lt;-done
}
</code></pre>
<h2 id="Range-over-Channels"><a href="/2019/06/08/gobyexample/#Range-over-Channels" class="headerlink" title="Range over Channels"></a>Range over Channels</h2><p>在前面的例子中，我们看到如何使用 for 和 range 来遍历基本的数据结构。我们同样可以使用这个语法来遍历通道上接收的值。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 遍历 queue 通道上的 2 个值</span>
  queue:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">2</span>)
  queue&lt;-<span class="string">"one"</span>
  queue&lt;-<span class="string">"two"</span>
  <span class="built_in">close</span>(queue)
  <span class="comment">//range 遍历通道上接收的每个值。由于在上面关闭了通道，这个遍历将在接收 2 个值后结束。</span>
  <span class="keyword">for</span> elem:=<span class="keyword">range</span> queue{
    fmt.Println(elem)
  }
}
</code></pre>
<h2 id="Timers"><a href="/2019/06/08/gobyexample/#Timers" class="headerlink" title="Timers"></a>Timers</h2><p>我们常想在未来的某一刻执行 Go 代码，或者在某一时间内重复执行。Go 内置的 timer 和 ticker 使这些任务十分简易。首先我们看看 timer，然后再看 ticker。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//timer 代表未来的一个单独事件。你要告诉它要等待多久，它提供一个通道，在指定时间发出通知。下面这个 timer 将等待 2 秒钟</span>
  timer1:=time.NewTimer(time.Second*<span class="number">2</span>)
  <span class="comment">// 定时器通道由于操作 &lt;-timer1.c 发生阻塞，直到它发送了一个值来表明定时器到时</span>
  &lt;-timer1.C
  fmt.Println(<span class="string">"Timer 1 expired"</span>)
  <span class="comment">// 如果你仅仅想等待一段时间，可以用 time.Sleep，使用 timer 的一个原因是，你可以在计时结束前取消，如下例：</span>
  timer2:=time.NewTimer(time.Second)
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    &lt;-timer2.C
    fmt.Println(<span class="string">"Timer 2 expired"</span>)
  }()
  stop2:=timer2.Stop()
  <span class="keyword">if</span> stop2{
    fmt.Println(<span class="string">"Timer 2 stopped"</span>)
  }
}
</code></pre>
<p>第一个 timer 将在启动程序后大约 2 秒到时，但第二个应会在其有机会到时前先行停止。</p>
<h2 id="Tickers"><a href="/2019/06/08/gobyexample/#Tickers" class="headerlink" title="Tickers"></a>Tickers</h2><p>timer 用来在将来的某一时间做某事一次。而 ticker 会在一个指定时间间隔重复做某事。这里是一个 ticker 的例子，它会在我们停止之前定期触发。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//ticker 与 timer 的机制相似，都是一个发送值的通道</span>
  <span class="comment">// 这里我们使用 channel 内置的 range 来遍历每 500ms 到达的值</span>
  ticker:=time.NewTicker(time.Millisecond*<span class="number">500</span>)
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    <span class="keyword">for</span> t:=<span class="keyword">range</span> ticker.C{
    fmt.Prinltn(<span class="string">"Tick at"</span>,t)
    }
  }()
  <span class="comment">//ticker 可以像 timer 一样停止。一旦 ticker 停止，将不会在其通道上接收到任何信息。我们将在 1600ms 后结束。</span>
  time.Sleep(time.Millisecond*<span class="number">1600</span>)
  ticker.Stop()
  fmt.Println(<span class="string">"Ticker stopped"</span>)
}
</code></pre>
<p>运行这个程序，在结束之前，应该会 tick 三次。</p>
<h2 id="Worker-Pools"><a href="/2019/06/08/gobyexample/#Worker-Pools" class="headerlink" title="Worker Pools"></a>Worker Pools</h2><p>本例中我们将看到如何使用 goroutine 和 channel 来实现一个工人池</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="comment">// 这里是我们将要运行多个并发实例的工人。他们将从 jobs 通道获取任务，并将相应的结果返回到 results 上。我们将在每个作业沉睡 1 秒，来模拟一个复杂的任务。</span>
<span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>,jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>,results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span>{
  <span class="keyword">for</span> j:=<span class="keyword">range</span> jobs{
    fmt.Println(<span class="string">"worker"</span>,id,<span class="string">"started job"</span>,j)
    time.Sleep(time.Second)
    fmt.Println(<span class="string">"worker"</span>,id,<span class="string">"finished job"</span>,j)
    results &lt;- j*<span class="number">2</span>
  }
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 为了使用工人池，我们需要派发任务并且回收结果。我们使用两个通道来做这件事</span>
  jobs:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)
  results:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)
  <span class="comment">// 这里启动了 3 个工人，初始时阻塞，因为当前没有作业</span>
  <span class="keyword">for</span> w:=<span class="number">1</span>;w&lt;=<span class="number">3</span>;w++{
    <span class="keyword">go</span> worker(w,jobs,results)
  }
  <span class="comment">// 添加 5 个作业，然后关闭通道来表明这就是所有的工作</span>
  <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++{
    jobs&lt;-j
  }
  <span class="built_in">close</span>(jobs)

  <span class="keyword">for</span> a:=<span class="number">1</span>;a&lt;=<span class="number">5</span>;a++{
    &lt;-results
  }
}
</code></pre>
<p>运行的项目展示了有 5 个作业得以被不同的工人执行。尽管总共有 5 秒钟的时间，这个程序只需要 2 秒钟，因为有 3 名工作人员同时进行操作。</p>
<blockquote>
<p>同时启动了 3 个 worker，来监听通道是否有作业发出，无作业时 worker 不会进入循环体，为空操作。从而形成工人池</p>
</blockquote>
<h2 id="Rate-Limiting"><a href="/2019/06/08/gobyexample/#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h2><p>速率限制是控制资源利用和维护服务质量的重要机制。Go 通过 goroutine，channel 和 ticker 可以优雅的支持速率控制。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 首先，我们看下基本的速率控制。</span>
  <span class="comment">// 假设我们想要控制处理的输入请求，我们通过同一个通道来为这些请求提供服务</span>
  requests:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">5</span>)
  <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++{
    request&lt;-i
  }
  <span class="built_in">close</span>(requests)
  <span class="comment">//limiter 通道将每过 200 毫秒接收一次数据。这是速率控制策略中的调节器</span>
  limiter:=time.Tick(time.Millisecond*<span class="number">200</span>)
  <span class="comment">// 在服务每个请求之前，通过 limiter 通道阻塞接收，我们将自己限制在每 200ms 处理 1 个请求上。</span>
  <span class="keyword">for</span> req:=<span class="keyword">range</span> request{
    &lt;-limiter
    fmt.Println(<span class="string">"request"</span>,req,time.now())
  }
  <span class="comment">// 我们可能希望在我们的速率限制方案中允许短时间的请求，同时保留整体速率限制。 </span>
  <span class="comment">// 我们可以通过缓冲限制器通道来实现这一点。</span>
  <span class="comment">// 这个 burstyLimiter 通道将允许多达 3 个事件的突发。</span>
  burstyLimiter:=<span class="built_in">make</span>(<span class="keyword">chan</span> time.Time,<span class="number">3</span>)
  <span class="comment">// 填充通道，来展示可允许的突发</span>
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++{
    burstyLimiter&lt;-time.Now()
  }
  <span class="comment">// 每过 200 毫秒将试图添加一个新值到 burstyLimiter，最多 3 个</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    <span class="keyword">for</span> t:=<span class="keyword">range</span> time.Tick(time.Millisecond*<span class="number">200</span>){
      burstyLimiter&lt;-t
    }
  }()
  <span class="comment">// 模拟 5 个输入请求。前 3 个将受益于 burstyLimiter 的突发能力</span>
  burstyRequests:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">5</span>)
  <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++{
    burstyRequest&lt;-i
  }
  <span class="built_in">close</span>(burstyRequests)
  <span class="keyword">for</span> req:=<span class="keyword">range</span> burstyRequests{
    &lt;-burstyLimiter
    fmt.Println(<span class="string">"request"</span>,req,time.Now())
  }
}
</code></pre>
<p>运行我们的程序，我们看到第一批请求根据需要每 200 毫秒处理一次。</p>
<p>对于第二批请求，由于可突发速率限制，我们立即为前 3 个服务，然后以约 200ms 的延迟提供剩余的 2 个。</p>
<h2 id="Atomic-Counters"><a href="/2019/06/08/gobyexample/#Atomic-Counters" class="headerlink" title="Atomic Counters"></a>Atomic Counters</h2><p>Go 中管理状态的主要机制是通过渠道进行沟通。 我们以工人池为例。 还有一些管理状态的其他选项。 这里我们来看一下使用 sync / atomic 包来进行多个 goroutines 访问的原子计数器。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"sync/atomic"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 我们使用无符号整数来代表我们的计数器</span>
  <span class="keyword">var</span> ops unit64=<span class="number">0</span>
  <span class="comment">// 为了模拟并发更新操作，我们将启动 50 个 goroutine，每个都会在每过 1 毫秒时增长一次计数器</span>
  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++{
    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
      <span class="keyword">for</span>{
        <span class="comment">// 为了原子地增加计数器，我们使用 AddUint64，使用＆语法给它我们的 ops 计数器的内存地址。</span>
        atomic.AddUnit64(&amp;ops,<span class="number">1</span>)
        <span class="comment">// 在两个增长之间稍作等待</span>
        time.Sleep(time.Millisecond)
      }
    }()
  }
  <span class="comment">// 等一下让一些操作积累起来。</span>
  time.Sleep(time.Second)
  <span class="comment">// 为了安全地使用计数器，当它仍被其他 goroutine 更新时，我们通过 LoadUint64 将当前值的副本提取到 opsFinal 中。</span>
  <span class="comment">// 如上所述，我们需要给出这个函数来获取值的内存地址和操作。</span>
  opsFinal:=atomic.LoadUnit64(&amp;ops)
  fmt.Println(<span class="string">"ops:"</span>,opsFinal)
}
</code></pre>
<p>运行程序可以看到我们执行了大约 40,000 次操作。</p>
<h2 id="Mutexes"><a href="/2019/06/08/gobyexample/#Mutexes" class="headerlink" title="Mutexes"></a>Mutexes</h2><p>在前面的例子中我们看到如何使用原子操作管理简单的计数器状态。为了处理更复杂的状态，我们可以使用一个<code>mutext</code>来安全的访问不同 gorotine 之间的数据。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span>(
  <span class="string">"fmt"</span>
  <span class="string">"math/rand"</span>
  <span class="string">"sync"</span>
  <span class="string">"sync/atomic"</span>
  <span class="string">"time"</span>
)
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这个例子中，状态是一个 map</span>
  <span class="keyword">var</span> state=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)
  <span class="comment">// 这个 mutext 将同步访问状态值</span>
  <span class="keyword">var</span> mutex=&amp;sync.Mutex{}
  <span class="comment">// 我们将记录做了多少读写操作</span>
  <span class="keyword">var</span> readOps unit64=<span class="number">0</span>
  <span class="keyword">var</span> writeOps unit64=<span class="number">0</span>
  <span class="comment">// 这里我们启动了 100 个 goroutine 来重复读取状态值</span>
  <span class="comment">// 每毫秒在每个 goroutine 执行一次</span>
  <span class="keyword">for</span> r:=<span class="number">0</span>;r&lt;<span class="number">100</span>;r++{
    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
      total:=<span class="number">0</span>
      <span class="keyword">for</span>{
        <span class="comment">// 每次读取时我们将获得一个进入的钥匙</span>
        <span class="comment">//Lock() 住 mutex 来保证独家访问状态值</span>
        <span class="comment">// 在选中的钥匙上读取值，Unlock() 掉 mutext</span>
        <span class="comment">// 对 readOps 计数加 1</span>
        key:=rand.Intn(<span class="number">5</span>)
        mutex.Lock()
        total+=state[key]
        mutex.Unlock()
        atomic.AddUnit64(&amp;readOps,<span class="number">1</span>)
        <span class="comment">// 每次操作等待一下</span>
        time.Sleep(time.Millisecond)
      }
    }()
  }
  <span class="comment">// 再启动 10 个模拟写的 goroutine，与读取类似的模式</span>
  <span class="keyword">for</span> w:=<span class="number">0</span>;w&lt;<span class="number">10</span>;w++{
    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
      <span class="keyword">for</span>{
        key:=rand.Intn(<span class="number">5</span>)
        val:=rand.Intn(<span class="number">100</span>)
        mutex.Lock()
        state[key]=val
        mutex.Unlock()
        atomic.AddUnit64(&amp;writeOps,<span class="number">1</span>)
        time.Sleep(time.Millisecond)
      }
    }()
  }
  <span class="comment">// 让这 10 个 go 协程在 state 和 mutext 上工作一会儿</span>
  time.Sleep(time.Second)
  <span class="comment">// 获取并且报告最终操作的个数。</span>
  readOpsFinal:=atomic.LoadUnit64(&amp;readOps)
  fmt.Println(<span class="string">"readOps:"</span>,readOpsFinal)
  writeOpsFinal:=atomic.LoadUnit64(&amp;writeOps)
  fmt.Println(<span class="string">"writeOps:"</span>,writeOpsFinal)
  <span class="comment">// 随着最后一次锁住状态，展示它是如何结束的</span>
  mutex.Lock()
  fmt.Println(<span class="string">"state:"</span>,state)
  mutex.Unlock()
}
</code></pre>
<p>运行程序可以看到我们在 mutex 同步状态上执行了将近 90,000 操作。</p>
<h2 id="Stateful-Goroutines"><a href="/2019/06/08/gobyexample/#Stateful-Goroutines" class="headerlink" title="Stateful Goroutines"></a>Stateful Goroutines</h2><p>在上个例子我们使用 mutex 显式锁定多个 goroutine 要同步访问的共享状态。另一个选择是使用 goroutine 和 channel 内置的同步功能来达到相同的结果。这种基于渠道的方法与 Go 通过通信和拥有完全一个 goroutine 的每个数据来共享内存的想法相一致。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span>(
  <span class="string">"fmt"</span>
  <span class="string">"math/rand"</span>
  <span class="string">"sync/atomic"</span>
  <span class="string">"time"</span>
)
<span class="comment">// 在这个例子中，状态值将被一个单独的 goroutine 拥有</span>
<span class="comment">// 这保证了数据不会受到并发访问的影响</span>
<span class="comment">// 为了读或写状态值，其它 goroutine 将向拥有它的 goroutine 发送一个消息，然后接收其回复。</span>
<span class="comment">//readOp 和 writeOp 结构封装了这些请求和响应</span>
<span class="keyword">type</span> readOp <span class="keyword">struct</span>{
  key <span class="keyword">int</span>
  resp <span class="keyword">chan</span> <span class="keyword">int</span>
}
<span class="keyword">type</span> writeOp <span class="keyword">struct</span>{
  key <span class="keyword">int</span>
  val <span class="keyword">int</span>
  resp <span class="keyword">chan</span> <span class="keyword">bool</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
  <span class="comment">// 像之前一样我们记录执行了多少次操作</span>
  <span class="keyword">var</span> readOp unit64=<span class="number">0</span>
  <span class="keyword">var</span> writeOps unit64=<span class="number">0</span>
  <span class="comment">//reads 和 writes 通道将被用于其它 goroutine 分别发送读写请求</span>
  reads:=<span class="built_in">make</span>(<span class="keyword">chan</span> *readOp)
  writes:=<span class="built_in">make</span>(<span class="keyword">chan</span> *writeOp)
  <span class="comment">// 这里便是拥有状态值的 goroutine，与之前一样是个 map，但被私有化</span>
  <span class="comment">// 这个 goroutine 反复选择 reads 和 writes 通道，响应到达的请求。</span>
  <span class="comment">// 首先执行所请求的操作然后在响应通道上发送值来表示成功执行响应</span>
  <span class="comment">//(或者 reads 期望的数据)</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    <span class="keyword">var</span> state=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)
    <span class="keyword">for</span>{
      <span class="keyword">select</span>{
      <span class="keyword">case</span> read:=&lt;-reads:
        read.resp&lt;-state[read.key]
      <span class="keyword">case</span> write:=&lt;-writes:
        state[write.key]=write.val
        write.resp&lt;-<span class="literal">true</span>
      }
    }
  }()
  <span class="comment">// 启动 100 个 goroutine，通过读取通道来读取有状态的 goroutine</span>
  <span class="comment">// 每次读取需要构建一个 readOp，通过 reads 发送给它</span>
  <span class="comment">// 再通过所提供的 resp 通道获取结果</span>
  <span class="keyword">for</span> r:=<span class="number">0</span>;r&lt;<span class="number">100</span>;r++{
    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
      <span class="keyword">for</span> {
        read:=&amp;readOp{
          key:rand.Intn(<span class="number">5</span>),
          resp:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
        }
        reads&lt;-read
        &lt;-read.resp
        atomic.AddUnit64(&amp;readOps,<span class="number">1</span>)
        time.Sleep(time.Millisecond)
      }
    }()
  }
  <span class="comment">// 启动 10 个写操作</span>
  <span class="keyword">for</span> w:=<span class="number">0</span>;w&lt;<span class="number">10</span>;w++{
    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
      <span class="keyword">for</span> {
        write:=&amp;writeOp{
          key:rand.Intn(<span class="number">5</span>),
          val:rand.Intn(<span class="number">100</span>),
          resp:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)
        }
      }
    }()
  }
  time.Sleep(time.Second)
  readOpsFinal:=atomic.LoadUnit64(&amp;readOps)
  fmt.Println(<span class="string">"readOps:"</span>,readOpsFinal)
  writeOpsFinal:=atomic.LoadUnit64(&amp;writeOps)
  fmt.Println(<span class="string">"writeOps:"</span>,writeOpsFinal)
}
</code></pre>
<p>运行项目显示基于 gouroutine 的状态管理完成了大约 80,000 操作。</p>
<h2 id="Sorting"><a href="/2019/06/08/gobyexample/#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><p>sort 包实现了内置和自定义类型的排序。首先看看内置类型的排序。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"sort"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//sort 改变了给定的 slice，而不是返回一个新的</span>
  strs:=[]<span class="keyword">string</span>{<span class="string">"c"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>}
  sort.Strings(strs)
  fmt.Println(<span class="string">"Strings:"</span>,strs)
  ints:=[]<span class="keyword">int</span>{<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>}
  sort.Ints(ints)
  fmt.Println(<span class="string">"Ints:"</span>,ints)
  <span class="comment">// 可以使用 sort 检查一个 slice 是不是已经排好序了</span>
  s:=sort.IntsAreSorted(ints)
  fmt.Println(<span class="string">"Sorted:"</span>,s)
}
</code></pre>
<h2 id="Sorting-by-Functions"><a href="/2019/06/08/gobyexample/#Sorting-by-Functions" class="headerlink" title="Sorting by Functions"></a>Sorting by Functions</h2><p>有时候我们想要对一个集合进行非自然顺序的排序。例如，我们想要把字符串根据长度而非字典顺序排序，下面是一个定制排序的例子。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"sort"</span>
<span class="comment">// 为了根据自定义函数排序，我们需要相应的类型</span>
<span class="comment">// 这里我们创建了一个 ByLength 类型</span>
<span class="comment">// 这就是一个 []string 类型的别名</span>
<span class="keyword">type</span> ByLength []<span class="keyword">string</span>
<span class="comment">// 我们在 ByLength 上实现了 sort 接口的 Len、Less 和 Swap 方法</span>
<span class="comment">// 这里我们想要按照字符串长度的增序排列</span>
<span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>{
  <span class="keyword">return</span> <span class="built_in">len</span>(s)
}
<span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span>{
  s[i],s[j] = s[j],s[i]
}
<span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {
  <span class="keyword">return</span> <span class="built_in">len</span>(s[i])&lt;<span class="built_in">len</span>(s[j])
}
<span class="comment">// 通过将原有的 fruits 片段转换为 ByLength</span>
<span class="comment">// 就可以使用 sort.Sort 来进行自定义排序了。</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  fruits:=[]<span class="keyword">string</span>{<span class="string">"peach"</span>,<span class="string">"banana"</span>,<span class="string">"kiwi"</span>}
  sort.Sort(ByLength(fruits))
  fmt.Println(fruits)
}
</code></pre>
<p>通过类似的模式创建自定义类型，实现三个接口方法，然后调用 sort，我们可以对集合进行任意的排序。</p>
<h2 id="Panic"><a href="/2019/06/08/gobyexample/#Panic" class="headerlink" title="Panic"></a>Panic</h2><p><code>panic</code>通常指发生了未曾预料的错误。大多数情况下，我们使用它来将不应当在正常操作中发生的东西快速失败，或者不准备妥善处理。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 我们将在整个网站使用 panic 来检查意外的错误。</span>
  <span class="comment">// 这是该网站上唯一旨在 panic 的程序。</span>
  <span class="built_in">panic</span>(<span class="string">"a problem"</span>)
  <span class="comment">//panic 的一个常见作用是终止一个函数返回了一个不知道如何处理或者不想处理的错误。</span>
  <span class="comment">// 这里是一个 panic 的例子，在创建一个新文件时发生意外错误</span>
  _,err:=os.Create(<span class="string">"/tmp/file"</span>)
  <span class="keyword">if</span> err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
}
</code></pre>
<p>运行这个程序将引起一个 panic，打印错误信息和 goroutine 踪迹，并以非 0 状态退出。</p>
<p>注意，不像一些用异常来处理大多错误的语言，在 Go 的习惯用法中，尽可能使用错误指示的返回值。</p>
<h2 id="Defer"><a href="/2019/06/08/gobyexample/#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>defer 用于确保一个函数调用在程序执行中延迟作用，经常用于清理目的。<code>defer</code>常用语其他语言的<code>ensure</code>和<code>finnaly</code>用的地方。</p>
<pre><code class="golang">packgae main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="comment">// 假设我们想要创建并写一个文件，在完成后关闭它。</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 在获取一个文件对象后立即使用 defer 并关闭这个文件</span>
  <span class="comment">// 这个将在 main 函数末尾关闭的时候执行，在 writeFile 完成后</span>
  f:=createFile(<span class="string">"/tmp/defer.txt"</span>)
  <span class="keyword">defer</span> closeFile(f)
  writeFile(f)
}
<span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="keyword">string</span>)</span> *<span class="title">os</span>.<span class="title">File</span></span>{
  fmt.Println(<span class="string">"creating"</span>)
  f,err:=os.Create(p)
  <span class="keyword">if</span> err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
  <span class="keyword">return</span> f
}
<span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span>{
  fmt.Println(<span class="string">"writing"</span>)
  fmt.Println(f,<span class="string">"data"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span>{
  fmt.Println(<span class="string">"closing"</span>)
  f.Close()
}
</code></pre>
<p>运行程序，确认这个文件的确在写之后再关闭的。</p>
<h2 id="Collection-Functions"><a href="/2019/06/08/gobyexample/#Collection-Functions" class="headerlink" title="Collection Functions"></a>Collection Functions</h2><p>我们经常需要我们的程序对数据集合执行操作，例如选择满足给定谓词的所有项目或将所有项目映射到具有自定义函数的新集合。</p>
<p>一些语言通常的惯用法是使用泛型数据结构和算法。 Go 不支持泛型; 在 Go 中，通常在程序和数据类型特别需要时提供集合功能。</p>
<p>以下是一些用于字符串切片的示例集合函数。 您可以使用这些示例来构建自己的函数。 请注意，在某些情况下，直接内联集合操作代码可能是最为清晰的，而不是创建和调用帮助函数。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"strings"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 返回目标字符串 t 的第一个索引，如果没有找到则返回 -1</span>
<span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(vs []<span class="keyword">string</span>,t <span class="keyword">string</span>)</span> <span class="title">int</span></span>{
  <span class="keyword">for</span> i,v:=<span class="keyword">range</span> vs{
    <span class="keyword">if</span> v==t{
      <span class="keyword">return</span> i
    }
  }
  <span class="keyword">return</span> <span class="number">-1</span>
}
<span class="comment">// 如果字符串在切片中，则返回 true</span>
<span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(vs []<span class="keyword">string</span>,t <span class="keyword">string</span>)</span> <span class="title">bool</span></span>{
  <span class="keyword">return</span> Index(vs,t)&gt;=<span class="number">0</span>
}
<span class="comment">// 如果有一个字符串满足期望的 f 则返回 true</span>
<span class="function"><span class="keyword">func</span> <span class="title">Any</span><span class="params">(vs []<span class="keyword">string</span>,f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span>{
  <span class="keyword">for</span> _,v:=<span class="keyword">range</span> vs{
    <span class="keyword">if</span> f(v){
      <span class="keyword">return</span> <span class="literal">true</span>
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>
}
<span class="comment">// 所有的字符串满足期望的 f 则返回 true</span>
<span class="function"><span class="keyword">func</span> <span class="title">All</span><span class="params">(vs []<span class="keyword">string</span>,f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span>{
  <span class="keyword">for</span> _,v:=<span class="keyword">range</span> vs{
    <span class="keyword">if</span> !f(v){
      <span class="keyword">return</span> <span class="literal">false</span>
    }
  }
  <span class="keyword">return</span> <span class="literal">true</span>
}
<span class="comment">// 返回一个满足给定方法的所有字符串</span>
<span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(vs []<span class="keyword">string</span>,f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>)[]<span class="title">string</span></span>{
  vsf :=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)
  <span class="keyword">for</span> _,v:=<span class="keyword">range</span> vs{
    <span class="keyword">if</span> f(v){
      vsf=<span class="built_in">append</span>(vsf,v)
    }
  }
  <span class="keyword">return</span> vsf
}
<span class="comment">// 返回一个包含将 f 函数应用于原始切片中每个字符串的结果的新切片。</span>
<span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(vs []<span class="keyword">string</span>,f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>)[] <span class="title">string</span></span>{
  vsm := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="built_in">len</span>(vs))
  <span class="keyword">for</span> i,v:=<span class="keyword">range</span> vs{
    vsm[i]=f(v)
  }
  <span class="keyword">return</span> vsm
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="keyword">var</span> strs=[]<span class="keyword">string</span>{<span class="string">"peach"</span>,<span class="string">"apple"</span>,<span class="string">"pear"</span>,<span class="string">"plum"</span>}
  fmt.Println(Index(strs,<span class="string">"pear"</span>))
  fmt.Println(Include(strs,<span class="string">"grape"</span>))
  fmt.Println(Any(strs,<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span>{
    <span class="keyword">return</span> strings.HasPrefix(v,<span class="string">"p"</span>)
  }))
  fmt.Println(All(strs,<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span>{
    <span class="keyword">return</span> strings.HasPrefix(v,<span class="string">"p"</span>)
  }))
  fmt.Println(Filter(strs,<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span>{
    <span class="keyword">return</span> strings.Contains(v,<span class="string">"e"</span>)
  }))
  <span class="comment">// 以上示例全部使用匿名函数，但也可以使用正确类型的命名函数。</span>
  fmt.Println(Map(strs,strings.ToUpper))
}
</code></pre>
<h2 id="String-Functions"><a href="/2019/06/08/gobyexample/#String-Functions" class="headerlink" title="String Functions"></a>String Functions</h2><p>标准库的 String 包提供了许多有用的字符串相关的函数。这里有些示例让你对这个包有个初步的认识。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> s <span class="string">"strings"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="comment">// 鉴于后文大量用到，我们给字符串输出函数起一个别名</span>
<span class="keyword">var</span> p=fmt.Println
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里是字符串可以用的函数示例</span>
  <span class="comment">// 由于这些函数是包中的而不是字符串对象本身的方法，我们需要给他们传递一个字符串参数</span>
  <span class="comment">// 你可以在 strings 包下的 doc 找到更多的函数</span>
  p(<span class="string">"Contains:"</span>,s.Contains(<span class="string">"test"</span>,<span class="string">"es"</span>))
  p(<span class="string">"Count:"</span>,s.Count(<span class="string">"test"</span>,<span class="string">"t"</span>))
  p(<span class="string">"HasPrefix:"</span>,s.HasPrefix(<span class="string">"test"</span>,<span class="string">"te"</span>))
  p(<span class="string">"HasSuffix:"</span>,s.HasSuffix(<span class="string">"test"</span>,<span class="string">"st"</span>))
  p(<span class="string">"Index:"</span>,s.Index(<span class="string">"test"</span>,<span class="string">"e"</span>))
  p(<span class="string">"Join:"</span>,s.Join([]<span class="keyword">string</span>{<span class="string">"a"</span>,<span class="string">"b"</span>},<span class="string">"-"</span>))
  p(<span class="string">"Repeat:"</span>,s.Repeat(<span class="string">"a"</span>,<span class="number">5</span>))
  p(<span class="string">"Replace:"</span>,s.Replace(<span class="string">"foo"</span>,<span class="string">"o"</span>,<span class="string">"0"</span>,<span class="number">-1</span>))
  p(<span class="string">"Replace"</span>,s.Replace(<span class="string">"foo"</span>,<span class="string">"o"</span>,<span class="string">"0"</span>,<span class="number">1</span>))
  p(<span class="string">"Split:"</span>,s.Split(<span class="string">"a-b-c-d-e"</span>,<span class="string">"-"</span>))
  p(<span class="string">"ToLower:"</span>,s.ToLower(<span class="string">"TEST"</span>))
  p(<span class="string">"ToUpper:"</span>,s.ToUpper(<span class="string">"test"</span>))
  p()
  <span class="comment">// 并非 strings 包的一部分，但是这里值得一提</span>
  <span class="comment">// 即获取字符串长度以及字符串中的某个字符</span>
  p(<span class="string">"Len:"</span>,<span class="built_in">len</span>(<span class="string">"hello"</span>))
  p(<span class="string">"Char:"</span>,<span class="string">"hello"</span>[<span class="number">1</span>])
}
</code></pre>
<p>注意，获取长度和索引字符是工作在字节级别上的。Go 使用 UTF-8 编码字符串。</p>
<h2 id="String-Formatting"><a href="/2019/06/08/gobyexample/#String-Formatting" class="headerlink" title="String Formatting"></a>String Formatting</h2><p>Go 在经典的<code>printf</code>上提供了优秀的字符串格式化支持。这里有一些常见格式化的例子。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="keyword">type</span> point <span class="keyword">struct</span>{
  x,y <span class="keyword">int</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//Go 提供了一些修饰符来格式化一般的 Go 数值</span>
  <span class="comment">// 例如，这里输出了一个 point 结构体的实例</span>
  p:=point{<span class="number">1</span>,<span class="number">2</span>}
  fmt.Printf(<span class="string">"%v\n"</span>,p)
  <span class="comment">// 如果值是结构体，%+v 变量将输出结构体中的域名称</span>
  fmt.Printf(<span class="string">"%+v\n"</span>,p)
  <span class="comment">//%#v 将打印 Go 语法形式</span>
  fmt.Printf(<span class="string">"%#v\n"</span>,p)
  <span class="comment">// 要想打印值的类型，使用 %T</span>
  fmt.Printf(<span class="string">"%T\n"</span>,p)
  <span class="comment">// 格式化输出布尔值</span>
  fmt.Printf(<span class="string">"%t\n"</span>,<span class="literal">true</span>)
  <span class="comment">// 整数有许多格式化选项，使用 %d 来进行标准十进制格式化</span>
  fmt.Printf(<span class="string">"%d\n"</span>,<span class="number">123</span>)
  <span class="comment">// 这样打印了二进制形式</span>
  fmt.Printf(<span class="string">"%b\n"</span>,<span class="number">14</span>)
  <span class="comment">// 这里打印了十进制数字对应的字符</span>
  fmt.Printf(<span class="string">"%c\n"</span>,<span class="number">33</span>)
  <span class="comment">//%x 提供了十六进制编码</span>
  fmt.Printf(<span class="string">"%x\n"</span>,<span class="number">456</span>)
  <span class="comment">// 浮点数也有许多格式化选项，标准十进制使用 %f</span>
  fmt.Printf(<span class="string">"%f\n"</span>,<span class="number">78.9</span>)
  <span class="comment">//%e 和 %E 格式化浮点数为科学计数法</span>
  fmt.Printf(<span class="string">"%e\n"</span>,<span class="number">123400000.0</span>)
  fmt.Printf(<span class="string">"%E\n"</span>,<span class="number">123400000.0</span>)
  <span class="comment">// 基本的字符串输出，使用 %s</span>
  fmt.Pirntf(<span class="string">"%s\n"</span>,<span class="string">"\"string\""</span>)
  <span class="comment">// 将 Go 代码中的字符串加引号输出 (等同参数形式)</span>
  fmt.Printf(<span class="string">"%q\n"</span>,<span class="string">"\"string\""</span>)
  <span class="comment">// 将字符串十六进制编码化</span>
  fmt.Printf(<span class="string">"%x\n"</span>,<span class="string">"hex this"</span>)
  <span class="comment">// 打印一个指针</span>
  fmt.Printf(<span class="string">"%p\n"</span>,&amp;p)
  <span class="comment">// 控制数字输出的宽度和精度，在 % 后面跟上数字可以控制宽度,. 后面跟上数字控制精度</span>
  <span class="comment">// 默认靠右显示，用空格填充</span>
  fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>,<span class="number">12</span>,<span class="number">345</span>)
  fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>,<span class="number">1.2</span>,<span class="number">3.45</span>)
  <span class="comment">// 靠左对齐使用 -</span>
  fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>,<span class="number">1.2</span>,<span class="number">3.45</span>)
  <span class="comment">// 你可能也需要控制字符串输出的格式，特别是要以表格形式输出的时候</span>
  fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>,<span class="string">"foo"</span>,<span class="string">"b"</span>)
  fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>,<span class="string">"foo"</span>,<span class="string">"b"</span>)
  <span class="comment">//Printf 将格式化的字符串打印到标准输出上</span>
  <span class="comment">//Sprintf 格式化并返回这个字符串而不打印</span>
  s:=fmt.Sprintf(<span class="string">"a %s"</span>,<span class="string">"string"</span>)
  fmt.Println(s)
  <span class="comment">// 你也可以格式化并打印到 io.Writers 而非 os.StdOut</span>
  fmt.Fprintf(os.Stderr,<span class="string">"an %s\n"</span>,<span class="string">"error"</span>)
}
</code></pre>
<h2 id="Regular-Expressions"><a href="/2019/06/08/gobyexample/#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h2><p>Go 为正则表达式提供了内置的支持。这里是一些常用的正则相关的任务。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"bytes"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"regexp"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 测试模式是否符合字符串</span>
  math,_:=regexp.MatchString(<span class="string">"p([a-z]+)ch"</span>,<span class="string">"peach"</span>)
  fmt.Printf(match)
  <span class="comment">// 上面我们直接使用了字符串模式。但是对于其他正则任务，你需要先编译一个正则表达式结构体</span>
  r,_:=regexp.Compile(<span class="string">"p([a-z]+)ch"</span>)
  <span class="comment">// 这种结构体上有许多方法。这里是一个如同上面的匹配测试</span>
  fmt.Println(r.MatchString(<span class="string">"peach"</span>))
  <span class="comment">// 这里找到一个匹配</span>
  fmt.Println(r.FindString(<span class="string">"peach punch"</span>))
  <span class="comment">// 这里也是寻找第一个匹配，但返回起止的索引而非字符串</span>
  fmt.Println(r.FindStringIndex(<span class="string">"peach punch"</span>))
  <span class="comment">//submatch 包含整串匹配，也包含内部的匹配。</span>
  fmt.Println(r.FindStringSubmatch(<span class="string">"peach punch"</span>))
  <span class="comment">// 与上面类似，返回整串匹配和内部匹配的索引信息</span>
  fmt.Println(r.FindStringSubmatchIndex(<span class="string">"peach punch"</span>))
  <span class="comment">// 这些函数的 All 修饰将返回输入中所有匹配的，不仅仅是第一个。例如找到所有匹配正则表达式的</span>
  fmt.Println(r.FindAllString(<span class="string">"peach punch pinch"</span>,<span class="number">-1</span>))
  fmt.Println(r.FindAllStringSubmatchIndex(<span class="string">"peach punch pinch"</span>,<span class="number">-1</span>))
  <span class="comment">// 第二个参数如果是非负数，则将限制最多匹配的个数</span>
  fmt.Println(r.FindAllString(<span class="string">"peach punch pinch"</span>,<span class="number">2</span>))
  <span class="comment">// 例子中都是字符串参数，并且用了类似于 MatchString 这样的名字</span>
  <span class="comment">// 我们可以提供 []byte 参数，并将函数名中的 String 去掉</span>
  fmt.Println(r.Match([]<span class="keyword">byte</span>(<span class="string">"peach"</span>)))
  <span class="comment">// 当用正则表达式创建一个常量的时候你可以使用 MustCompile。</span>
  <span class="comment">// 一个纯 Compile 不能用于常量，因为它有 2 个返回值。</span>
  r=regexp.MustComplie(<span class="string">"p([a-z]+)ch"</span>)
  fmt.Println(r)
  <span class="comment">//regexp 包也能用于使用其他值替换字符串的子集</span>
  fmt.Println(r.ReplaceAllString(<span class="string">"a peach"</span>,<span class="string">"&lt;fruit&gt;"</span>))
  <span class="comment">//Func 修饰允许你使用一个给定的函数修改匹配的字符串</span>
  in:=[]<span class="keyword">byte</span>(<span class="string">"a peach"</span>)
  out:=r.ReplaceAllFunc(in,bytes.ToUpper)
  fmt.Println(<span class="keyword">string</span>(out))
}
</code></pre>
<h2 id="JSON"><a href="/2019/06/08/gobyexample/#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Go 内置提供了 JSON 的编码和解码是，包括内置和自定义的数据类型。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"encoding/json"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="comment">// 我们使用这两个结构体来展示自定义类型的编码和解码</span>
<span class="keyword">type</span> Response1 <span class="keyword">struct</span>{
  Page <span class="keyword">int</span>
  Fruits []<span class="keyword">string</span>
}
<span class="keyword">type</span> Response2 <span class="keyword">struct</span>{
  Page <span class="keyword">int</span> <span class="string">`json:"page"`</span>
  Fruits []<span class="keyword">string</span> <span class="string">`json:"fruits"`</span>
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 首先我们来看编码基本数据类型到 JSON 字符串。</span>
  <span class="comment">// 这里有一些原子类型的示例</span>
  bolB,_:=json.Marshal(<span class="literal">true</span>)
  fmt.Println(<span class="keyword">string</span>(bolB))
  intB,_:=json.Marshal(<span class="number">1</span>)
  fmt.Println(<span class="keyword">string</span>(intB))
  fltB,_:=json.Marshal(<span class="number">2.34</span>)
  fmt.Println(<span class="keyword">string</span>(fltB))
  strB,_:=json.Marshal(<span class="string">"gopher"</span>)
  fmt.Println(<span class="keyword">string</span>(strB))
  <span class="comment">// 这里有些 slice 和 map 的例子，他们将按需编码成 JSON 数组和对象。</span>
  slcD:=[]<span class="keyword">string</span>{<span class="string">"apple"</span>,<span class="string">"peach"</span>,<span class="string">"pear"</span>}
  slcB,_:=json.Marshal(slcD)
  fmt.Println(<span class="keyword">string</span>(slcB))
  mapD:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>{<span class="string">"apple"</span>:<span class="number">5</span>,<span class="string">"lettuce"</span>:<span class="number">7</span>}
  mapB,_:=json.Marshal(mapD)
  fmt.Println(<span class="keyword">string</span>(mapB))
  <span class="comment">//JSON 包将自动编码你的自定义数据类型</span>
  <span class="comment">// 他将在编码后的输出中只包含对外的域并且用名字作为 JSON 键</span>
  res1D:=&amp;Response1{
    Page:<span class="number">1</span>,
    Fruits:[]<span class="keyword">string</span>{<span class="string">"apple"</span>,<span class="string">"peach"</span>,<span class="string">"pear"</span>}
  }
  res1B,_:=json.Marshal(res1D)
  fmt.Println(<span class="keyword">string</span>(res1B))
  <span class="comment">// 你可以在结构体的域声明上定制编码后的 JSON 键名。</span>
  <span class="comment">// 可以看上面 Reponse2 的定义</span>
  res2D:=&amp;Reponse2{
    Page:<span class="number">1</span>,
    Fruits:[]<span class="keyword">string</span>{<span class="string">"apple"</span>,<span class="string">"peach"</span>,<span class="string">"pear"</span>}
  }
  res2B,_:=json.Marshal(res2D)
  fmt.Println(<span class="keyword">string</span>(res2B))
  <span class="comment">// 我们需要提供一个变量来放 JSON 包编码的值。</span>
  <span class="comment">//map[string]interface{} 将承载一个字符串数据类型的 map</span>
  byt:=[]<span class="keyword">byte</span>(<span class="string">`{"num":6.13,"strs":["a","b"]}`</span>)
  <span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}
  <span class="comment">// 这里是相应的解码，以及相关错误的检查</span>
  <span class="keyword">if</span> err:=json.Unmarshal(byt,&amp;dat);err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
  fmt.Println(dat)
  <span class="comment">// 为了使用解码的 map 的值，我们需要将它们转换为合适的类型</span>
  <span class="comment">// 例如这里我们将 num 中饿值转变为 float64 类型</span>
  num:dat[<span class="string">"num"</span>].(<span class="keyword">float64</span>)
  fmt.Println(num)
  <span class="comment">// 访问内部数据需要一系列的转换</span>
  strs:=dat[<span class="string">"strs"</span>].([]<span class="keyword">interface</span>{})
  str1:=strs[<span class="number">0</span>].(<span class="keyword">string</span>)
  fmt.Println(str1)
  <span class="comment">// 我们也可以将 JSON 解码到定制的数据类型</span>
  <span class="comment">// 这样为程序添加了额外的类型安全，并不再需要在访问数据的时候进行类型断言</span>
  str:=<span class="string">`{"page":1,"fruits":["apple","peach"]}`</span>
  res:=Response2{}
  json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;res)
  fmt.Println(res)
  fmt.Println(res.Fruits[<span class="number">0</span>])
  <span class="comment">// 在上面的例子中我们经常使用 bytes 和字符串在标准输出上来进行数据和 JSON 形式的交互</span>
  <span class="comment">// 我们也可以将 JSON 编码流入到 os.Writers 甚至 HTTP 响应体</span>
  enc:json.NewEncoder(os.Stdout)
  d:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>{<span class="string">"apple"</span>:<span class="number">5</span>,<span class="string">"lettuce"</span>:<span class="number">7</span>}
  enc.Encode(d)
}
</code></pre>
<h2 id="Time"><a href="/2019/06/08/gobyexample/#Time" class="headerlink" title="Time"></a>Time</h2><p>Go 为时间和持续时间提供了额外支持。这里是一些例子。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  p:=fmt.Pritnln
  <span class="comment">// 首先获取当前时间</span>
  now:=time.Now()
  p(now)
  <span class="comment">// 你可以创建一个时间结构体，提供年月日等。</span>
  <span class="comment">// 时间经常与地区，例如时区关联</span>
  then:=time.Date(<span class="number">2009</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">34</span>,<span class="number">58</span>,<span class="number">651387237</span>,time.UTC)
  p(then)
  <span class="comment">// 可以按照需要抽取时间变量中的不同部分</span>
  p(then.Year())
  p(then.Month())
  p(then.Day())
  p(then.Hour())
  p(then.Minute())
  p(then.Second())
  p(then.Nanosecond())
  p(then.Location())
  p(then.Weekday())
  p(then.Before(now))
  p(then.After(now))
  p(then.Equal(now))
  <span class="comment">//sub 方法返回两个时间中的时间长度</span>
  diff:=now.Sub(then)
  p(diff)
  <span class="comment">// 我们可以计算不同单位的持续时间长度</span>
  p(diff.Hours())
  p(diff.Minutes())
  p(diff.Seconds())
  p(diff.Nanoseconds())
  <span class="comment">// 可以使用 Add 来向前推进一个给定的时间</span>
  <span class="comment">// 或者使用减号来倒退</span>
  p(then.Add(diff))
  p(then.Add(-diff))
}
</code></pre>
<h2 id="Epoch"><a href="/2019/06/08/gobyexample/#Epoch" class="headerlink" title="Epoch"></a>Epoch</h2><p>程序中的一个常见需求是获取秒、毫秒或微秒，自 Unix 时代，这里是 Go 的做法。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  now:=time.Now()
  secs:=now.Unix()
  nanos:=now.UnixNano()
  fmt.Println(now)
  millis:=nanos/<span class="number">1000000</span>
  fmt.Println(secs)
  fmt.Println(millis)
  fmt.Println(nanos)
  fmt.Println(time.Unix(secs,<span class="number">0</span>))
  fmt.Println(time.Unix(<span class="number">0</span>,nanos))
}
</code></pre>
<h2 id="Time-Formatting-Parsing"><a href="/2019/06/08/gobyexample/#Time-Formatting-Parsing" class="headerlink" title="Time Formatting / Parsing"></a>Time Formatting / Parsing</h2><p>Go 支持时间格式化和解析，根据基于模式的布局。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  p:=fmt.Println
  <span class="comment">// 这里是一个根据 RFC3339 基本的格式化时间的例子，使用响应的布局常量</span>
  t:=time.Now()
  p(t.Format(time.RFC3339))
  <span class="comment">// 时间解析使用格式化相同的布局值</span>
  t1,e:=time.Parse(
    time.RFC3339,
    <span class="string">"2012-11-01T22:08:41+00:00"</span>
  )
  p(t1)
  <span class="comment">// 格式化和解析使用基于示例的布局</span>
  <span class="comment">// 通常你使用常量在进行布局。但你也可以提供自定义的格式。</span>
  <span class="comment">// 但你必须使用 Mon Jan 2 15:04:05 MST 2006 来作为示例</span>
  p(t.Format(<span class="string">"3:04PM"</span>))
  p(t.Format(<span class="string">"Mon Jan _2 15:04:05 2006"</span>))
  p(t.Format(<span class="string">"2006-01-02T15:04:05.999999-07:00"</span>))
  form:=<span class="string">"3 04 PM"</span>
  t2,e:=time.Parse(form,<span class="string">"8 41 PM"</span>)
  p(t2)
  <span class="comment">// 纯数字展示你可以使用标准的字符串格式化及响应部分的时间值</span>
  fmt.Printf(<span class="string">"%d-%02d-%02dT%02d:%02d:%02d-00:00\n"</span>,
    t.Year(),t.Month(),t.Day(),
    t.Hour(),t.Minute(),t.Second()
  )
  <span class="comment">// 解析返回一个错误来说明是什么问题</span>
  ansic:=<span class="string">"Mon Jan _2 15:04:05 2006"</span>
  _,e=time.Parse(ansic,<span class="string">"8:41PM"</span>)
  p(e)
}
</code></pre>
<h2 id="Random-Numbers"><a href="/2019/06/08/gobyexample/#Random-Numbers" class="headerlink" title="Random Numbers"></a>Random Numbers</h2><p>Go 的 math/rand 包提供产生伪随机数。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"time"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"math/rand"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 例如，rand.Intn 产生一个随机的整数 n，0&lt;=n&lt;100</span>
  fmt.Print(rand.Intn(<span class="number">100</span>),<span class="string">","</span>)
  fmt.Print(rand.Intn(<span class="number">100</span>))
  fmt.Println()
  <span class="comment">//rand.Float64 返回一个随机的浮点数，0.0&lt;=f&lt;1.0</span>
  fmt.Println(rand.Float64())
  <span class="comment">// 这个可以用于产生其他区间的浮点数，如 5.0&lt;=f&lt;10.0</span>
  fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>,<span class="string">","</span>)
  fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>)
  fmt.Println()
  <span class="comment">// 默认的数字产生器是 deterministic，故它每次善生的数字序列是固定的</span>
  <span class="comment">// 为了产生不同的序列，赋予它一个变化的种子</span>
  <span class="comment">// 注意，随即数字用来加密并不安全，用 crypto/rand 来做</span>
  s1:=rand.NewSource(time.Now().UnixNano())
  r1:=rand.New(s1)
  <span class="comment">// 调用产生的 rand.Rand</span>
  fmt.Print(r1.Intn(<span class="number">100</span>),<span class="string">","</span>)
  fmt.Print(r1.Intn(<span class="number">100</span>))
  fmt.Println()
  <span class="comment">// 如果你给 Source 设置了相同的数字种子，他将产生相同的随即数字序列。</span>
  s2:=rand.NewSrouce(<span class="number">42</span>)
  r2:=rand.New(s2)
  fmt.Print(r2.Intn(<span class="number">100</span>),<span class="string">","</span>)
  fmt.Print(r2.Intn(<span class="number">100</span>))
  fmt.Println()
  s3:=rand.NewSource(<span class="number">42</span>)
  r3:=rand.New(s3)
  fmt.Print(r3.Intn(<span class="number">100</span>),<span class="string">","</span>)
  fmt.Print(r3.Intn(<span class="number">100</span>))
}
</code></pre>
<h2 id="Number-Parsing"><a href="/2019/06/08/gobyexample/#Number-Parsing" class="headerlink" title="Number Parsing"></a>Number Parsing</h2><p>从字符串中解析数字是一个常见的任务，这里是 Go 的做法。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="comment">// 内置的 strconv 包提供了数字解析</span>
<span class="keyword">import</span> <span class="string">"strconv"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//64 代表要解析的浮点数精度</span>
  f,_:=strconv.ParseFloat(<span class="string">"1.234"</span>,<span class="number">64</span>)
  fmt.Println(f)
  <span class="comment">//0 代表根据字符串推断基数，64 要求结果要适应 64 位</span>
  i,_:=strconv.ParseInt(<span class="string">"123"</span>,<span class="number">0</span>,<span class="number">64</span>)
  fmt.Println(i)
  <span class="comment">//ParseInt 可以识别十六进制</span>
  d,_:=strconv,Parseint(<span class="string">"0x1c8"</span>,<span class="number">0</span>,<span class="number">64</span>)
  fmt.Println(d)
  u,_:=strconv.ParseUint(<span class="string">"789"</span>,<span class="number">0</span>,<span class="number">64</span>)
  fmt.Println(u)
  <span class="comment">//atoi 是十进制整数解析的简便函数</span>
  k,_:=strconv.Atoi(<span class="string">"135"</span>)
  fmt.Println(k)
  <span class="comment">// 不合法的输入将导致解析函数返回一个错误</span>
  _,e:=strconv.Atoi(<span class="string">"wat"</span>)
  fmt.Println(e)
}
</code></pre>
<h2 id="URL-Parsing"><a href="/2019/06/08/gobyexample/#URL-Parsing" class="headerlink" title="URL Parsing"></a>URL Parsing</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"net"</span>
<span class="keyword">import</span> <span class="string">"net/url"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 我们解析这个示例 URL，包含一个协议，授权信息，地址，端口，路径，查询参数以及查询拆分</span>
  s:=<span class="string">"postgres://user:pass@host.com:5432/path?k=v#f"</span>
  <span class="comment">// 解析这个 URL 并且保证没有错误</span>
  u,err:=url.Parse(s)
  <span class="keyword">if</span> err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
  <span class="comment">// 可以直接访问协议</span>
  fmt.Println(u.Scheme)
  <span class="comment">//User 包含所有授权信息，调用 Username 和 Password 可以得到单独的值</span>
  fmt.Println(u.User)
  fmt.Println(u.User.Username())
  p,_:=u.User.Password()
  fmt.Println(p)
  <span class="comment">//Host 包含地址和端口。使用 SplitHostPort 来抽取他们</span>
  fmt.Println(u.Host)
  host,port,_:=net.SplitHostPort(u.Host)
  fmt.Println(host)
  fmt.Println(port)
  fmt.Println(u.Path)
  fmt.Println(u.Fragment)
  <span class="comment">// 为了以 k=v 的格式得到查询参数，使用 RawQuery</span>
  <span class="comment">// 你也可以将查询参数解析到一个 map 中</span>
  <span class="comment">// 解析的查询参数是从字符串到字符串的片段，故索引 0 可以只得到第一个值</span>
  fmt.Println(u.RawQuery)
  m,_:=url.ParseQuery(u.RawQuery)
  fmt.Println(m)
  fmt.Println(m[<span class="string">"k"</span>][<span class="number">0</span>])
}
</code></pre>
<h2 id="SHA1-Hashes"><a href="/2019/06/08/gobyexample/#SHA1-Hashes" class="headerlink" title="SHA1 Hashes"></a>SHA1 Hashes</h2><p>SHA1 哈希经常用于计算二进制或者文本块的短标识。例如，git 版本控制系统使用 SHA1 来标示文本和目录。这里是 Go 如何计算 SHA1 哈希值。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="comment">//Go 实现了多种哈希函数，在 crypto 包下</span>
<span class="keyword">import</span> <span class="string">"crypto/sha1"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  s:=<span class="string">"sha1 this string"</span>
  <span class="comment">// 产生一个哈希的模式是 sha1.New()，sha1.Write(bytes) 然后 sha1.Sum([]bytes{})</span>
  h:=sha1.New()
  h.Write([]<span class="keyword">byte</span>(s))
  <span class="comment">// 这里得到最终的哈希结果字节片段值。参数用于向已存在的字节片段追加，通常不需要</span>
  bs:=h.Sum(<span class="literal">nil</span>)
  <span class="comment">//SHA1 值经常用于打印成十六进制，如 git 提交时。使用 %x 格式参数来转换为十六进制</span>
  fmt.Println(s)
  fmt.Printf(<span class="string">"%x\n"</span>,bs)
}
</code></pre>
<h2 id="Base64-Encoding"><a href="/2019/06/08/gobyexample/#Base64-Encoding" class="headerlink" title="Base64 Encoding"></a>Base64 Encoding</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="comment">// 这里为引入的包起了名称，来节省下面代码的空间</span>
<span class="keyword">import</span> b64 <span class="string">"encoding/base64"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  data:=<span class="string">"abc123!?$*&amp;()'-=@~"</span>
  sEnc:=b64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(data))
  fmt.Println(sEnc)
  sDec,_:=b64.StdEncoding.DecodeString(sEnc)
  fmt.Println(<span class="keyword">string</span>(sDec))
  fmt.Println()
  uEnc:=b64.URLEncoding.EncodeToString([]<span class="keyword">byte</span>(data))
  fmt.Println(uEnc)
  uDec,_:=b64.URLEncoding.DecodeString(uEnc)
  fmt.Println(<span class="keyword">string</span>(uDec))
}
</code></pre>
<h2 id="Reading-Files"><a href="/2019/06/08/gobyexample/#Reading-Files" class="headerlink" title="Reading Files"></a>Reading Files</h2><p>读取和写入文件是许多 Go 程序的基本任务需求。首先我们来看读取文件。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span>(
  <span class="string">"bufio"</span>
  <span class="string">"fmt"</span>
  <span class="string">"io"</span>
  <span class="string">"io/ioutil"</span>
  <span class="string">"os"</span>
)
<span class="comment">// 读取文件需要检查大多数调用是否错误，这个 helper 可以流水化错误检查</span>
<span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span>{
  <span class="keyword">if</span> e!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(e)
  }
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 最基本的一个文件读取任务是将所有内容放入内存中</span>
  dat,err:=ioutil.ReadFile(<span class="string">"/tmp/dat"</span>)
  check(err)
  fmt.Print(<span class="keyword">string</span>(dat))
  <span class="comment">// 如果你想对文件的那部分如何进行读取有更多的控制</span>
  <span class="comment">// 首先你需要打开它</span>
  f,err:=os.Open(<span class="string">"/tmp/dat"</span>)
  check(err)
  <span class="comment">// 从文件的开头读取一些字节。允许到 5，同时也是实际读取了的字节。</span>
  b1:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">5</span>)
  n1,err:=f.Read(b1)
  check(err)
  fmt.Printf(<span class="string">"%d bytes: %s\n"</span>,n1,<span class="keyword">string</span>(b1))
  <span class="comment">// 你也可以找到一个已知的位置并从那里开始读取</span>
  o2,err:=f.Seek(<span class="number">6</span>,<span class="number">0</span>)
  check(err)
  b2:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">2</span>)
  n2,err:=f.Read(b2)
  check(err)
  fmt.Printf(<span class="string">"%d bytes @[](https://hacpai.com/member/)  %d: %s\n"</span>,n2,o2,<span class="keyword">string</span>(b2))
  <span class="comment">//io 包提供了一些函数，对于文件读取可能很有帮助</span>
  <span class="comment">// 例如上面的继续读取的例子，可以使用 ReadAtLeast 更稳定的实现</span>
  o3,err:=f.Seek(<span class="number">6</span>,<span class="number">0</span>)
  check(err)
  b3:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">2</span>)
  n3,err:=io.ReadAtLeast(f,b3,<span class="number">2</span>)
  check(err)
  fmt.Printf(<span class="string">"%d bytes @[](https://hacpai.com/member/)  %d: %s\n"</span>,n3,o3,<span class="keyword">string</span>(b3))
  <span class="comment">// 没有内置的退回，但是 Seek(0,0) 完成了这个事情</span>
  _,err=f.Seek(<span class="number">0</span>,<span class="number">0</span>)
  check(err)
  <span class="comment">//bufio 包实现了一个带缓冲区的读取，它对于一些小的读取以及由于它所提供的额外方法会很有帮助</span>
  r4:=bufio.NewReader(f)
  b4,err:=r4.Peek(<span class="number">5</span>)
  check(err)
  fmt.Printf(<span class="string">"5 bytes: %s\n"</span>,<span class="keyword">string</span>(b4))
  <span class="comment">// 在完成时关闭文件 (通常会在打开时通过 defer 计划执行)</span>
  f.Close()
}
</code></pre>
<h2 id="Writing-Files"><a href="/2019/06/08/gobyexample/#Writing-Files" class="headerlink" title="Writing Files"></a>Writing Files</h2><p>写文件与读取的模式类似。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span>(
  <span class="string">"bufio"</span>
  <span class="string">"fmt"</span>
  <span class="string">"io/ioutil"</span>
  <span class="string">"os"</span>
)
<span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span>{
  <span class="keyword">if</span> e!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(e)
  }
}
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 这里将一个字符串 (或者仅仅是字节) 写入到一个文件。</span>
  d1:=[]<span class="keyword">byte</span>(<span class="string">"hello\ngo\n"</span>)
  err:=ioutil.WriteFile(<span class="string">"/tmp/dat1"</span>,d1,<span class="number">0644</span>)
  check(err)
  <span class="comment">// 打开一个文件以供写入</span>
  f,err:=os.Create(<span class="string">"/tmp/dat2"</span>)
  check(err)
  <span class="comment">// 这是一个惯用法，在打开时立刻通过 defer 关闭</span>
  <span class="keyword">defer</span> f.Close()
  d2:=[]<span class="keyword">byte</span>{<span class="number">115</span>,<span class="number">111</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">10</span>}
  n2,err:=f.Write(d2)
  check(err)
  fmt.Printf(<span class="string">"wrote %d bytes\n"</span>,n2)
  n3,err:=f.WriteString(<span class="string">"writes\n"</span>)
  fmt.Printf(<span class="string">"wrote %d bytes\n"</span>,n3)
  f.Sync()
  w:=bufio.NewWriter(f)
  n4,err:=w.WriteString(<span class="string">"buffered\n"</span>)
  fmt.Printf(<span class="string">"wrote %d bytes\n"</span>,n4)
  w.Flush()
}
</code></pre>
<h2 id="Line-Filters"><a href="/2019/06/08/gobyexample/#Line-Filters" class="headerlink" title="Line Filters"></a>Line Filters</h2><p>一个行过滤器经常见于读取标准输入流的输入，处理然后输出到标准输出的程序中。grep 和 sed 是常见的行过滤器。</p>
<pre><code class="golang"><span class="comment">// 下面这个行过滤器示例将所有输入的文字转换为大写的版本</span>
<span class="keyword">package</span> main
<span class="keyword">import</span> (
  <span class="string">"bufio"</span>
  <span class="string">"fmt"</span>
  <span class="string">"os"</span>
  <span class="string">"strings"</span>
)
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 使用一个带缓冲的 scanner 可以方便的使用 Scan 方法来直接读取一行</span>
  <span class="comment">// 每次调用该方法可以让 scanner 读取下一行</span>
  scanner:=bufio.NewScanner(os.Stdin)
  <span class="comment">//Text 方法返回当前的 token，现在是输入的下一行</span>
  <span class="keyword">for</span> scanner.Scan(){
    ucl:=strings.ToUpper(scanner.Text())
    <span class="comment">// 输出大写的行</span>
    fmt.Println(ucl)
  }
  <span class="comment">// 检查 scanner 的错误，文件结束符不会被当作是一个错误</span>
  <span class="keyword">if</span> err:=scanner.Err();err!=<span class="literal">nil</span>{
    fmt.Fprintln(os.Stderr,<span class="string">"error:"</span>,err)
    os.Exit(<span class="number">1</span>)
  }
}
</code></pre>
<p>可以使用如下命令来试验这个行过滤器：</p>
<blockquote>
<p>$ echo ‘hello’ &gt; /tmp/lines<br>$ echo ‘filter’ &gt;&gt; /tmp/lines<br>$ cat /tmp/lines | go run line-filters.go</p>
</blockquote>
<h2 id="Command-Line-Arguments"><a href="/2019/06/08/gobyexample/#Command-Line-Arguments" class="headerlink" title="Command-Line Arguments"></a>Command-Line Arguments</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//os.Args 提供原始命令行参数访问功能</span>
  <span class="comment">// 切片的第一个值是程序的路径</span>
  argsWithProg:=os.Args
  <span class="comment">//os.Args[1:] 保存程序的所有参数</span>
  argsWithoutProg:=os.Args[<span class="number">1</span>:]
  <span class="comment">// 你可以通过自然索引获取到每个单独的参数</span>
  arg:=os.Args[<span class="number">3</span>]
  fmt.Println(argsWithProg)
  fmt.Println(argsWithoutProg)
  fmt.Println(arg)
}
</code></pre>
<p>本例应当先 go build，然后再运行并指定参数</p>
<h2 id="Command-Line-Flags"><a href="/2019/06/08/gobyexample/#Command-Line-Flags" class="headerlink" title="Command-Line Flags"></a>Command-Line Flags</h2><p>命令行标志是一个指定特殊选项的常用方法。例如，在 wc -l 的 -l 就是一个命令行标志。</p>
<pre><code class="golang"><span class="keyword">package</span> main
<span class="comment">//flag 包支持基本的命令行标志解析</span>
<span class="keyword">import</span> <span class="string">"flag"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 基本的标志声明仅支持字符串、整数和布尔值选项</span>
  <span class="comment">// 这里声明了一个默认值为 foo 的字符串标志 word，并带有一个简短的描述。flag.String 返回一个字符串指针。</span>
  wordPtr:=flag.String(<span class="string">"word"</span>,<span class="string">"foo"</span>,<span class="string">"a string"</span>)
  <span class="comment">// 类似声明一个整数和布尔值标志。</span>
  numbPtr:=flag.Int(<span class="string">"numb"</span>,<span class="number">42</span>,<span class="string">"an int"</span>)
  boolPtr:=flag.Bool(<span class="string">"fork"</span>,<span class="literal">false</span>,<span class="string">"a bool"</span>)
  <span class="comment">// 可以使用程序中已有的参数声明一个标志，声明时需要指定该参数的指针</span>
  <span class="keyword">var</span> svar <span class="keyword">string</span>
  flag.StringVar(&amp;svar,<span class="string">"svar"</span>,<span class="string">"bar"</span>,<span class="string">"a string var"</span>)
  <span class="comment">// 所有标志声明完成后，调用 flag.Parse() 来执行命令行解析</span>
  flag.Parse()
  <span class="comment">// 通过对指针解引用来获取选项的实际值</span>
  fmt.Println(<span class="string">"word:"</span>,*wordPtr)
  fmt.Println(<span class="string">"numb:"</span>,*numbPtr)
  fmt.Println(<span class="string">"fork:"</span>,*boolPtr)
  fmt.Println(<span class="string">"svar:"</span>,svar)
  fmt.Println(<span class="string">"tail:"</span>,flag.Args())
}
</code></pre>
<p>测试用例：</p>
<blockquote>
<p>$ go build command-line-flags.go<br># 省略的标志将自动设定为默认值<br>$ ./command-line-flags -word=opt<br># 位置参数可以出现在任何标志后面<br>$ ./command-line-flags -word=opt a1 a2 a3<br># flag 包需要的所有标志出现在位置参数之前，否则标志将会被解析为位置参数<br>$ ./command-line-flags -word=opt a1 a2 a3 -numb=7<br># 使用 -h 或者 –help标志来得到自动生成的命令行帮助文本<br>$ ./command-line-flags -h<br># 如果提供了一个没有用 flag 包指定的标志，将会得到错误信息和帮助文档<br>$ ./command-line-flags -wat</p>
</blockquote>
<h2 id="Environment-Variables"><a href="/2019/06/08/gobyexample/#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="keyword">import</span> <span class="string">"strings"</span>
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 使用 os.Setenv 来设置一个键值对</span>
  <span class="comment">// 使用 os.Getenv 来获取一个环境变量，如果不存在，返回空字符串</span>
  os.Setenv(<span class="string">"FOO"</span>,<span class="string">"1"</span>)
  fmt.Println(<span class="string">"FOO:"</span>,os.Getenv(<span class="string">"FOO"</span>))
  fmt.Println(<span class="string">"BAR:"</span>,os.Getenv(<span class="string">"BAR"</span>))
  fmt.Println()
  <span class="comment">// 使用 os.Environ 来列出所有环境变量键值对</span>
  <span class="keyword">for</span> _,e:=<span class="keyword">range</span> os.Environ(){
    pair:=strings.Split(e,<span class="string">"="</span>)
    fmt.Prinln(pair[<span class="number">0</span>])
  }
}
</code></pre>
<h2 id="Spawning-Processes"><a href="/2019/06/08/gobyexample/#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"io/iouitl"</span>
<span class="keyword">import</span> <span class="string">"os/exec"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//exec.Command 函数帮助我们创建一个表示这个外部进程的对象</span>
  dateCmd:=exec.Command(<span class="string">"date"</span>)
  <span class="comment">//Output 等待命令运行完成，并收集命令的输出</span>
  dateOut,err:=dateCmd.Output()
  <span class="keyword">if</span> err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
  fmt.Println(<span class="string">"&gt; date"</span>)
  fmt.Println(<span class="keyword">string</span>(dateOut))
  grepCmd:=exec.Command(<span class="string">"grep"</span>,<span class="string">"hello"</span>)
  <span class="comment">// 获取输入输出管道</span>
  grepIn,_:=grepCmd.StdinPipe()
  grepOut,_:=grepCmd.StdoutPipe()
  <span class="comment">// 运行进程，写入输入信息，读取输出结果，等待程序运行结束</span>
  grepCmd.Start()
  grepIn.Write([]<span class="keyword">byte</span>(<span class="string">"hello grep\ngoodbye grep"</span>))
  grepIn.Close()
  grepByte,_:=ioutil.ReadAll(grepOut)
  grepCmd.Wait()
  fmt.Println(<span class="string">"&gt; grep hello"</span>)
  fmt.Println(<span class="keyword">string</span>(grepBytes))
  <span class="comment">// 通过 bash 命令的 -c 选项来执行一个字符串包含的完整命令</span>
  lsCmd:=exec.Command(<span class="string">"bash"</span>,<span class="string">"-c"</span>,<span class="string">"ls -a -l -h"</span>)
  lsOut,err:=lsCmd.Output()
  <span class="keyword">if</span> err!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(err)
  }
  fmt.Println(<span class="string">"&gt; ls -a -l -h"</span>)
  fmt.Pritnln(<span class="keyword">string</span>(lsOut))
}
</code></pre>
<h2 id="Exec’ing-Processes"><a href="/2019/06/08/gobyexample/#Exec’ing-Processes" class="headerlink" title="Exec’ing Processes"></a>Exec’ing Processes</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"syscall"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="keyword">import</span> <span class="string">"os/exec"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 通过 LookPath 得到需要执行的可执行文件的绝对路径</span>
  binary,lookErr:=exec.LookPath(<span class="string">"ls"</span>)
  <span class="keyword">if</span> lookErr!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(lookErr)
  }
  <span class="comment">//Exec 需要的参数是切片形式的，第一个参数为执行程序名</span>
  args:=[]<span class="keyword">string</span>{<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>,<span class="string">"-h"</span>}
  env:=os.Environ()
  execErr:=syscall.Exec(binary,args,env)
  <span class="keyword">if</span> execErr!=<span class="literal">nil</span>{
    <span class="built_in">panic</span>(execErr)
  }
}
</code></pre>
<h2 id="Signals"><a href="/2019/06/08/gobyexample/#Signals" class="headerlink" title="Signals"></a>Signals</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="keyword">import</span> <span class="string">"os/signal"</span>
<span class="keyword">import</span> <span class="string">"syscall"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">//Go 通过向一个通道发送 os.Signal 值来进行信号通知</span>
  sigs:=<span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number">1</span>)
  <span class="comment">// 同时创建一个用于在程序可以结束时进行通知的通道</span>
  done:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)
  <span class="comment">// 注册给定通道用于接收特定信号</span>
  signal.Notify(sigs,syscall.SIGINT,syscall.SIGTERM)
  <span class="comment">//Go 协程执行一个阻塞的信号接收操作，当它得到一个值时，打印并通知程序可以退出</span>
  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{
    sig:=&lt;-sigs
    fmt.Println()
    fmt.Println(sig)
    done&lt;-<span class="literal">true</span>
  }()
  fmt.Println(<span class="string">"awaiting signal"</span>)
  &lt;-done
  fmt.Println(<span class="string">"exiting"</span>)
}
</code></pre>
<p>运行，使用 ctrl-c 发送信号</p>
<h2 id="Exit"><a href="/2019/06/08/gobyexample/#Exit" class="headerlink" title="Exit"></a>Exit</h2><pre><code class="golang"><span class="keyword">package</span> main
<span class="keyword">import</span> <span class="string">"fmt"</span>
<span class="keyword">import</span> <span class="string">"os"</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
  <span class="comment">// 当使用 os.Exit 时，defer 将不会执行</span>
  <span class="keyword">defer</span> fmt.Println(<span class="string">"!"</span>)
  <span class="comment">// 退出，并且状态为 3</span>
  os.Exit(<span class="number">3</span>)
}
</code></pre>
<p>官网：<a href="https://gobyexample.com" target="_blank" rel="noopener">https://gobyexample.com</a></p>

            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Go by Example》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/06/08/gobyexample/" property="cc:attributionName"
               rel="cc:attributionURL">
                MarkHoo
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2019/06/08/gobyexample/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="Go by Example">
                        
                        <span class="card-title">Go by Example</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Hello World我们第一个程序就是打印经典的“hello world”，下面是完整的代码
package main
import "fmt"
func main(){
  fmt.Println("hello world")
}

要
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-06-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Go/" class="post-category" target="_blank">
                                    Go
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Go/" target="_blank">
                        <span class="chip bg-color">Go</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/05/06/JWT/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="JWT简介">
                        
                        <span class="card-title">JWT简介</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文翻译自JWT官方网站对JWT是什么以及能做什么的简介。
JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（RFC 7519），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-05-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/默认分类/" class="post-category" target="_blank">
                                    默认分类
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JWT/" target="_blank">
                        <span class="chip bg-color">JWT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:xxx@xx.xx" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=123123123" class="tooltipped" data-tooltip="QQ联系我: 123123123" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>